<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[loud-links]]></title>
    <url>%2F2017%2F11%2F29%2Floud-links%2F</url>
    <content type="text"><![CDATA[想必大家玩过 APP 游戏，里面的按钮每点击一下都会有一个响声来回应你的点击状态，这是很不错的交互效果，若想在网页也能实现这样的交互声音，请看今天达人分享的 Lound links JS 插件，它可以实现这样效果！ Loud links这个WEB音效插件可以实现按钮与图片等元素的触发交互，比如鼠标 HOVER 后出现响声，或者鼠标点击后出现响声。本插件非常轻量级，官方介绍只有1.5KB大小，使用也相当简单。 下载&amp;演示：https://loudlinks.rocks/ 支持音频格式：mp3，ogg 达人体验了一下，使用这种方法还是不错的，从心理学角度来看，加入声音的交互，可以增加一点小小的惊喜。 关于 BUG，其实也不算 BUG，就是第一次使用的时候，声音会有延迟，这是因为第一次使用时需要下载声音文件，所以不建议使用大文件。 使用方法STEP 1.嵌入JS文件1&lt;script src=&quot;loud-links.js&quot;&gt;&lt;/script&gt; STEP 2.在需要触发的元素上加入对应class [loud-link-hover]为悬停触发声音 [loud-link-click]为点击触发声音 12&lt;div class=&quot;loud-link-hover&quot;&gt;hello world&lt;/div&gt; &lt;!-- sound on hover --&gt;&lt;div class=&quot;loud-link-click&quot;&gt;hello world&lt;/div&gt; &lt;!-- sound on click --&gt; STEP 3.使用[data-sound]或[data-src]来配置声音123456789方式一：绝对路径&lt;div class=&quot;loud-link-hover&quot; data-sound=&quot;http://example.com/audio/noise.&#123;&#123;type&#125;&#125;&quot;&gt;hello world&lt;/div&gt; //&#123;&#123;type&#125;&#125;为声音格式，比如 .mp3, .ogg方式二：使用声音名称&lt;div class=&quot;loud-link-hover&quot; data-sound=&quot;noise&quot;&gt;hello world&lt;/div&gt; //这里noise为声音名称，而文件必须存放到音频目录：/sounds/mp3/noise.mp3或/sounds/ogg/noise.ogg&lt;div class=&quot;loud-link-click&quot; data-src=&quot;noise&quot;&gt;hello world&lt;/div&gt; //这里noise为声音名称，而文件必须存放到音频目录：/sounds/mp3/noise.mp3或/sounds/ogg/noise.ogg 来自：http://www.shejidaren.com/loud-links-js-library.html 作者：设计达人]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS判断设备PC端或移动端而跳转到相应页面]]></title>
    <url>%2F2017%2F11%2F15%2FPCorPhone%2F</url>
    <content type="text"><![CDATA[随着互联网的快速发展，移动互联网开发势头迅猛，如今人手一部手机的时代，手机段网站需求也不断加大，因此我们需要通过JS语句来判断设备是PC端还是移动端，从而跳转到相应的页面。 User Agent的判断是识别浏览器的关键，通过User Agent判断桌面端设备或移动设备就变的很为重要。 12345if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123; window.location.href=&quot;你的手机版地址&quot;; &#125;else&#123; window.location.href=&quot;你的电脑版地址&quot;; &#125; 如有错误欢迎指出讨论 联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用——CSS]]></title>
    <url>%2F2017%2F11%2F08%2Foften-css%2F</url>
    <content type="text"><![CDATA[css有些属性容易忘记，半天不写就要去查api，有时候api还不好使，于是还是记下来以后方便用，后续会慢慢补充进来的。 移除当选中input元素的时候会出现状态线1234567An outline is a line that is drawn around elements (outside the borders) to make the element &quot;stand out&quot;.包裹elements 的一个线，一般设置成none 。div &#123; outline: none; //一般情况下移除它 // outline: 5px dotted red; 也可以设置样式&#125; contenteditable 设置element是否可编辑1&lt;p contenteditable=&quot;true&quot;&gt;可编辑&lt;/p&gt; 可以通过input, blur事件来监听element的输入和输入完后鼠标离开。 1webkit-playsinline 手机video 都可以在页面中播放，而不是全屏播放了。 1&lt;video src=&quot;test.mp4&quot; webkit-playsinline=&quot;true&quot;&gt;&lt;/video&gt; position: absolute， 让margin有效的12345678设置left:0, right:0 margin: 0 auto; 就可以。原因是2边都是0不存在边距，element就可以得出距离，并居中。div &#123; position: absolute; left: 0; right: 0; margin: 0 auto;&#125; 使用clearfix 清除浮动，解决父类高度崩塌。123456789101112.clearfix &#123; zoom: 1;&#125;.clearfix:after &#123; visibility: hidden; display: block; font-size: 0; content: &quot; &quot;; clear: both; height: 0; &#125; user-select 禁止用户选中文本123div &#123; user-select: none; /* Standard syntax */&#125; 清除手机tap事件后element 时候出现的一个高亮123* &#123; -webkit-tap-highlight-color: rgba(0,0,0,0);&#125; ::-webkit-scrollbar-thumb1可以修改浏览器的滚动条样式。IE火狐可能不支持。 -webkit-appearance:none To apply platform specific styling to an element that doesn’t have it by default To remove platform specific styling to an element that does have it by default 移除浏览器默认的样式，比如chrome的input默认样式，然后就可以定义需要的样式。 1234input, button, textarea, select &#123; *font-size: 100%; -webkit-appearance:none;&#125; CSS开启硬件加速http://www.cnblogs.com/rubylouvre/p/3471490.html 1-webkit-transform: translateZ(0); 使用CSS transforms 或者 animations时可能会有页面闪烁的bug1-webkit-backface-visibility: hidden; -webkit-touch-callout 禁止长按链接与图片弹出菜单1-webkit-touch-callout: none; transform-style: preserve-3d 让元素支持3d1234div &#123; transform: rotateY(60deg); transform-style: preserve-3d;&#125; perspective 透视这个属性的存在决定你看到的元素是2d还是3d。一般设置在包裹元素的父类上。 123.div-box &#123; perspective: 400px; &#125; css实现不换行、自动换行、强制换行123456789//不换行white-space:nowrap;//自动换行word-wrap: break-word; word-break: normal; //强制换行word-break:break-all; box-sizing 让元素的宽度、高度包含border和padding123&#123; box-sizing: border-box;&#125; calc() function, 计算属性值123div &#123; width: calc(100% - 100px);&#125; 上面的例子就是让宽度为100%减去100px的值，项目中很适用，IE9以上 css3 linear-gradient 线性渐变默认开始在top, 也可以自定义方向。 12345div &#123; linear-gradient(red, yellow)&#125;background: linear-gradient(direction, color-stop1, color-stop2, ...); 常用的选择器 :nth-child() Selector选择父类下第一个子节点，p元素 123p:nth-child(1) &#123; ...&#125; -webkit-font-smoothing 字体抗锯齿使用该属性能让页面上的字体变得清晰，但是也会造成font-weight: bold 加粗变得异常。不信你试试 123div &#123; -webkit-font-smoothing: antialiased; &#125; CSS3 filter Property 图片过滤12345678img &#123; filter: grayscale(100%); //灰度 filter: blur(5px); //模糊 filter:brightness(200%); //高亮 filter:saturate(8); //饱和 filter:sepia(100%); //怀旧 ...&#125; 使用css创建三角形这个很多面试题好像问到，但实际中我也确实使用了。 1234567div &#123; border-bottom: 10px solid white; border-right: 10px solid transparent; border-left: 10px solid transparent; height: 0px; width: 0px; &#125; transparent 透明 clip属性，截取你想要显示的图片1234img &#123; position: absolute; clip: rect(0px,60px,200px,0px);&#125; 设置文字，字母间距，很实用 letter-spacing123h1 &#123; letter-spacing: *px; //也可以是负数&#125; display: box 和 display: flex，前者是2009实施，后者2012年，如果你的安卓比较老请使用display: box，但是2者的表现可能有点不同。下面是兼容方法。123456display: -webkit-box; /* Chrome 4+, Safari 3.1, iOS Safari 3.2+ */display: -moz-box; /* Firefox 17- */display: -webkit-flex; /* Chrome 21+, Safari 6.1+, iOS Safari 7+, Opera 15/16 */display: -moz-flex; /* Firefox 18+ */display: -ms-flexbox; /* IE 10 */display: flex; /* Chrome 29+, Firefox 22+, IE 11+, Opera 12.1/17/18, Android 4.4+ */ 图片运动过程中，图片模糊问题在animation过程中，图片会出现模糊的情况，可以设置如下在图片上面。 1transform: translate3d(0, 0, 0); 使用margin aotu1234567891011div &#123; width: 100px; position: absolute; right: 0;&#125;// 使用margin-left: auto 自动算出做左边宽度，实现内容贴右边div &#123; width: 100px; margin-left: auto;&#125; 来自：https://juejin.im/post/58da53b7ac502e0058e70abf?utm_source=gold_browser_extension]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome原生截图、节点截图]]></title>
    <url>%2F2017%2F10%2F20%2FchromeTools1%2F</url>
    <content type="text"><![CDATA[Chrome62稳定版释出，除了常规修复各种安全问题外，还增加很多功能上的支持，比如说今天要介绍的强大的截图功能。 直接截图打开开发者工具页面，选择左上角的元素选择按钮（Inspect） 然后在Windows下按住Ctrl，Mac就按住Command，然后在页面拖动选择区域即可。 Chrome会自动使用下载方式进行存储(png格式) 节点截图比如说我们刚才手动截取的区域其实是一个Node节点，如果想完整截取这一部分，我们就需要使用节点截图功能。 首先在开发者工具里面选择节点，直接点选HTML即可。 然后按下快捷键Ctrl + Shift + p打开命令工具，Mac下就是Cmd + Shift + p，输入node选择Capture node screenshot即可，图片会自动下载。 那么我们真的不需要网页截图插件了，如果想截图整个网页，我们直接在根节点选取就可以了。 来自：https://juejin.im/post/59e80ad1f265da431e15dec7?utm_source=gold_browser_extension 如有错误请联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>tools</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F10%2F18%2Fregex%2F</url>
    <content type="text"><![CDATA[正则表达式，又称规则表达式，英文名为Regular Expression，在代码中常简写为regex、regexp或RE，是计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，模式描述在搜索文本时要匹配的一个或多个字符串。 正则表达式知识符号 {}&nbsp;&nbsp;&nbsp;——&nbsp;&nbsp;[] ^ $ | \ ? + * []&nbsp;&nbsp;&nbsp;——&nbsp;&nbsp;类 ()&nbsp;&nbsp;&nbsp;——&nbsp;&nbsp;分组 | &nbsp;&nbsp;&nbsp;&nbsp;——&nbsp;&nbsp;表示或 边界 \b &nbsp;&nbsp;——&nbsp;&nbsp;单词边界(表示单词的开始，结尾) \B &nbsp;&nbsp;——&nbsp;&nbsp;非单词边界(表示单词的开始，结尾) $ &nbsp;&nbsp;&nbsp;——&nbsp;&nbsp;表示以XX结束 ^ &nbsp;&nbsp;&nbsp;——&nbsp;&nbsp;表示以XX开始 类 [] ^ &nbsp;&nbsp;——&nbsp;&nbsp;在类里面表示非的意思 预定义类 . &nbsp;&nbsp;== [^\n\r] &nbsp;&nbsp;——&nbsp;&nbsp;除了回车符和换行符之外的所有字符 \d == [0-9] == [0123456789] \D == [^0-9] &nbsp;&nbsp;——&nbsp;&nbsp;除了数字以外的字符 \s == [\t\n\0B\f\r] &nbsp;&nbsp;——&nbsp;&nbsp;空白字符 \S == [^\t\n\0B\f\r] &nbsp;&nbsp;——&nbsp;&nbsp;非空白字符 \w == [a-zA-Z_0-9] &nbsp;&nbsp;——&nbsp;&nbsp;单词字符 （字母 下划线 数字） \W == [^a-zA-Z_0-9] &nbsp;&nbsp;——&nbsp;&nbsp;非单词字符 \t &nbsp;&nbsp;——&nbsp;&nbsp;水平制表 \n &nbsp;&nbsp;——&nbsp;&nbsp;换行 \f &nbsp;&nbsp;——&nbsp;&nbsp;换页 \r &nbsp;&nbsp;——&nbsp;&nbsp;回车 量词 ？ &nbsp;&nbsp;——&nbsp;&nbsp;出现零次或一次（最多出现一次） +&nbsp;&nbsp;&nbsp;——&nbsp;&nbsp;出现一次或多次（最少出现一次） *&nbsp;&nbsp;&nbsp;——&nbsp;&nbsp;出现0次或多次（任意次） {n} &nbsp;&nbsp;——&nbsp;&nbsp;出现n次 {n,m} &nbsp;&nbsp;——&nbsp;&nbsp;出现n到m次 {n,} &nbsp;&nbsp;——&nbsp;&nbsp;至少出现n次 {0,m} &nbsp;&nbsp;——&nbsp;&nbsp;最多出现m次 () &nbsp;&nbsp;——&nbsp;&nbsp;分组 igm reg.ignoreCase &nbsp;&nbsp;——&nbsp;&nbsp;返回正则的忽略大小写属性，默认为false，设置了之后返回true reg.global &nbsp;&nbsp;——&nbsp;&nbsp;返回正则的全局匹配属性，默认为false，设置了之后返回true reg.multiline &nbsp;&nbsp;——&nbsp;&nbsp;返回正则的多行匹配属性，默认为false，设置了之后返回true 一些常用的验证信息 QQ：/^[1-9]\d{4,11}$/ E-mail：/^[a-zA-Z_].{5,17}|\d{5,12}\@\w{2,7}.[a-z]{2,3}$/ 手机号：/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$/ 以上是我自己总结的，发现错误的请联系，我会及时修改。 转载标明出处或联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发总结]]></title>
    <url>%2F2017%2F06%2F17%2Fxiaochenxu%2F</url>
    <content type="text"><![CDATA[微信小程序（wei xin xiao cheng xu），简称小程序，缩写XCX，英文名Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。 微信开发者工具微信开发者工具下载 对应的服务器证书无效。控制台输入 showRequestInfo() 可以获取更详细信息小程序数据请求必须是https，没配证书用于调试可以先在项目设置中选择不校验安全域名、TLS版本以及HTTPS证书 按条件设置class12345678&lt;text wx:for=&quot;&#123;&#123;titles&#125;&#125;&quot; wx:key=&quot;&#123;&#123;item&#125;&#125;&quot; class=&quot;home-title &#123;&#123;index == activeIndex ? &apos;active&apos; : &apos;&apos;&#125;&#125;&quot; bindtap=&apos;changeClassify&apos;&gt; &#123;&#123;item.name&#125;&#125;&lt;/text&gt;// index == activeIndex classw为 &quot;home-title active&quot; 否则为 &quot;home-title &quot; 循环嵌套1234567891011121314151617// 普通的单次循环&lt;text wx:for=&quot;&#123;&#123;titles&#125;&#125;&quot; wx:key=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt;//循环嵌套时使用 wx:for-item=&quot;XXX&quot; &lt;view wx:for=&quot;&#123;&#123;hotArr&#125;&#125;&quot;&gt; &lt;view class=&quot;classify-title&quot; bindtap=&quot;goClassifyPage&quot;&gt; &lt;text&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;classify-items&quot;&gt; &lt;view class=&quot;classify-item&quot; wx:for=&quot;&#123;&#123;item.data&#125;&#125;&quot; wx:for-item=&quot;cell&quot; wx:key=&quot;index&quot;&gt; &lt;view&gt; &lt;text class=&quot;classify-item_name&quot;&gt;&#123;&#123;cell.name&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; router 跳转传参及参数获取123456789101112131415161718//wxml&lt;text wx:for=&quot;&#123;&#123;titles&#125;&#125;&quot; wx:key=&quot;&#123;&#123;index&#125;&#125;&quot; bindtap=&apos;changeClassify&apos; data-id=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt;//jsfunction changeClassify(e) &#123; let id = e.currentTarget.dataset.id; //跳转到classify 页面 wx.navigateTo(&#123; url: &apos;../classify/classify?id=&apos; + id &#125;)&#125;//classify 页面 获取参数onLoad: function (opts) &#123; console.log(opts.id) console.log(this.options.id)&#125; 上拉加载更多, 下拉刷新 直接使用小城程序自带方法onReachBottom、onPullDownRefresh 如果使用scroll-view组件还可以监听bindscrolltoupper、bindscrolltolower 123456789101112// 上拉加载更多onReachBottom: function() &#123; if (this.data.next != null) &#123; this.setData(&#123; isHideLoadMore: false &#125;) this.getNextPage() &#125;&#125;// 下拉刷新onPullDownRefresh: function() &#123; this.refreshData()&#125; 组件化template的使用对于通用的组件可以抽出一个template 1234567891011121314151617181920/*** 1. 给template 设置name* 2. 组件传过来的值可以直接使用 hidden=&quot;&#123;&#123;!isloading&#125;&#125;&quot;*/&lt;template name=&quot;loading&quot;&gt; &lt;view class=&quot;weui-loadmore&quot; hidden=&quot;&#123;&#123;!isloading&#125;&#125;&quot;&gt; &lt;view class=&quot;weui-loading&quot;&gt;&lt;/view&gt; &lt;view class=&quot;weui-loadmore__tips&quot;&gt;正在加载&lt;/view&gt; &lt;/view&gt; &lt;/template&gt;// /** * 使用通用的template * 1. 按路径引入* 2. 设置 is 等于 template的name data=&quot;&#123;&#123;isloading&#125;&#125;&quot; 给template的数据*/&lt;import src=&quot;../template/loading.wxml&quot;/&gt;&lt;template is=&quot;loading&quot; data=&quot;&#123;&#123;isloading&#125;&#125;&quot;&gt;&lt;/template&gt; 获取用户的UniqueID以及openidUniqueID以及openid的获取涉及到用户的敏感信息，返回的数据encryptedData是加密后的数据要提取信息需要对数据进行解密 官网提供了解密的算法，将nodejs的版本拿过来稍作修改即可 下载cryptojs放到项目的utils目录下 在utils 目录下新建decode.js写入以下内容 123456789101112131415161718192021222324252627282930313233343536373839//utils/decode.jsvar Crypto = require(&apos;./cryptojs/cryptojs.js&apos;).Crypto;function WXBizDataCrypt(appId, sessionKey) &#123; this.appId = appId this.sessionKey = sessionKey&#125;WXBizDataCrypt.prototype.decryptData = function (encryptedData, iv) &#123; // base64 decode ：使用 CryptoJS 中 Crypto.util.base64ToBytes()进行 base64解码 var encryptedData = Crypto.util.base64ToBytes(encryptedData) var key = Crypto.util.base64ToBytes(this.sessionKey); var iv = Crypto.util.base64ToBytes(iv); // 对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充 var mode = new Crypto.mode.CBC(Crypto.pad.pkcs7); try &#123; // 解密 var bytes = Crypto.AES.decrypt(encryptedData, key, &#123; asBpytes: true, iv: iv, mode: mode &#125;); var decryptResult = JSON.parse(bytes); &#125; catch (err) &#123; console.log(err) &#125; if (decryptResult.watermark.appid !== this.appId) &#123; console.log(err) &#125; return decryptResult &#125;module.exports = WXBizDataCrypt 在app.js 引入decode.js对数据进行解密 1234567891011121314151617181920212223242526272829303132333435363738var WXBizDataCrypt = require(&apos;utils/decode.js&apos;);var AppId = &apos;XXXXXX&apos; var AppSecret = &apos;XXXXXXXXX&apos;//app.jsApp(&#123; onLaunch: function () &#123; //调用登录接口 wx.login(&#123; success: function (res) &#123; wx.request(&#123; url: &apos;https://api.weixin.qq.com/sns/jscode2session&apos;, data: &#123; appid: AppId, secret: AppSecret, js_code: res.code, grant_type: &apos;authorization_code&apos; &#125;, header: &#123; &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125;, method: &apos;GET&apos;, success: function(res) &#123; var pc = new WXBizDataCrypt(AppId, res.data.session_key) wx.getUserInfo(&#123; success: function (res) &#123; var data = pc.decryptData(res.encryptedData, res.iv) console.log(&apos;解密后 data: &apos;, data) &#125; &#125;) &#125;, fail: function(res) &#123; &#125; &#125;) &#125; &#125;) &#125;&#125;) 注意：UniqueID的获取微信开放平台帐号必须已完成开发者资质认证，否则解密后的数据没有UniqueID字段 解密后数据 来自：https://juejin.im/post/59c20199f265da0658151cfe?utm_source=gold_browser_extension]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你可能不知道的 border-radius]]></title>
    <url>%2F2017%2F05%2F11%2Fradius%2F</url>
    <content type="text"><![CDATA[前言随着互联网的快速发展，互联网也进入了平民老板姓家。稍微有点能力的人也都有了各自的博客，网站。然而以前的网页杂而多，现在人们开始追求简洁美观大方的页面，不再求杂而多。 现在的网站大量的使用圆形，半圆，四分之一圆，椭圆，半椭圆，不规则圆。我们都知道CSS中的border-radius不只是画圆角那么简单，我们可以用它画各种圆，不规则圆。 普通的圆角常用的圆角样式123456.box&#123; height: 200px; width: 200px; background-color: pink; border-radius: 50px;&#125; 效果图： 标准的圆123456.box&#123; height: 200px; width: 200px; background-color: pink; border-radius: 50%;&#125; 效果图： 标准的圆1234567//注意这是一个矩形，他的“盒子最短边的二分之一”为50px;.box&#123; height: 100px; width: 200px; background-color: pink; border-radius: 50px;&#125; 效果图： 当我们继续加大border-radius的值时，是没有任何效果的，这也是为什么我们无法用这种方法画出椭圆的原因。 不规则圆角如果UI设计师告诉你，这个盒子四个圆角是不一样的，有大有小，也就是说这四个圆角的半径是不相同的，这个时候就要用到border-radius的拓展属性： 123456789.box&#123; height: 200px; width: 200px; background-color: pink; border-top-left-radius: 100px; border-top-right-radius: 50px; border-bottom-right-radius: 10px; border-bottom-left-radius: 25px;&#125; 效果图： 我们也可以简写，从左上角顺时针开始： 123456.box&#123; height: 200px; width: 200px; background-color: pink; border-radius: 100px 50px 10px 25px;&#125; 画一个半圆123456.box&#123; width: 200px; height: 200px; background-color: pink; border-radius: 200px 0 0 0;&#125; 效果图： 画一个四分子圆123456.box&#123; width: 200px; height: 100px; background-color: pink; border-radius: 200px 200px 0 0;&#125; 效果图： 垂直水平半径不相等(椭圆)的圆角水平半径与垂直半径以上我们都是基于标准圆来削去四个角，是无法得到一个椭圆形状的，为了让小伙伴们方便理解，我们先来介绍一个概念：水平半径与垂直半径： 如果要画一个椭圆，依照之前那种水平半径和垂直半径相等的圆角去削一个矩形是无法做到的，border-radius给我们提供了这样的方案： border-radius：水平半径 ／ 垂直半径; 有了这个方案我们，我们就能画一个用椭圆“削”的圆角图形： 123456.box&#123; height: 100px; width: 200px; background-color: pink; border-radius: 70px / 30px;&#125; 效果图： 画一个椭圆当我们把水平半径设置为矩形长的二分之一，垂直半径设置为矩形宽的二分之一时候，那么就能完美地画一个椭圆啦： 123456.box&#123; width: 200px; height: 100px; background-color: pink; border-radius: 100px / 50px;&#125; 效果图： 画一个半椭圆我们回想border-radius有四个角之分，那么我们是不是可以利用这一点画一个半圆呢： 123456.box&#123; width: 200px; height: 100px; background-color: pink; border-radius: 200px 0 0 200px / 50px 0 0 50px;&#125; 效果图： 画一个四分之一椭圆123456.box&#123; width: 200px; height: 100px; background-color: pink; border-radius: 200px 0 0 0 / 100px 0 0 0;&#125; 效果图： 奇形怪状的图画一个鸡蛋123456.box&#123; width: 100px; height: 200px; background-color: pink; border-radius: 50px 50px 50px 50px/150px 150px 50px 50px;&#125; 效果图： 千万要注意英文字符下的“/”和中文字符下的“／”是完全不一样的，小伙伴们不要写错了哦。 画一片树叶123456.box&#123; width: 200px; height: 200px; background-color: green; border-radius: 200px 0 200px 0;&#125; 效果图： 画一个爱心1234567891011121314151617181920212223242526272829&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style media=&quot;screen&quot;&gt; .box&#123; display: flex; justify-content: center; align-items: center; height: 400px; &#125; .box1&#123; width: 100px; height: 170px; background-color: red; border-radius: 50px 50px 0px 0; transform-origin: 50px 50px; transform: rotate(-45deg); &#125; .box2&#123; width: 100px; height: 170px; background-color: red; border-radius: 50px 50px 0px 0; transform-origin: 50px 50px; transform: rotate(45deg); &#125;&lt;/style&gt; 效果图： 总结这里只是抛砖引玉地讲解了基本原理，用border-radius可以画出很多有趣的图，当然我们也可以不必要都用px来写定了值，也可以用%来设置，只不过用px更不容易出错易控制，当需要自适应布局的时候，那么就需要用%来设置值。 来自：https://juejin.im/entry/59a6b268518825244b069616?utm_source=gold_browser_extension]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分电脑基础技能]]></title>
    <url>%2F2017%2F04%2F20%2FBasic-skills%2F</url>
    <content type="text"><![CDATA[运行命令功能电脑注销快捷键win+r打开运行窗口 然后输入logoff，确认 windows自带卸载软件快捷键win+r打开运行窗口 然后输入appwiz.cpl，确认 设置定时关机快捷键win+r打开运行窗口 然后输入shutdown -s -t 3600，确认 取消定时关机快捷键win+r打开运行窗口 然后输入shutdown -a，确认 windows自带计时器快捷键win+r打开运行窗口 然后输入calc，确认 windows自带录屏工具快捷键win+r打开运行窗口 然后输入psr.exe，确认 windows自带远程连接快捷键win+r打开运行窗口 然后输入mstsc，确认 windows自带记事本快捷键win+r打开运行窗口 然后输入notepad，确认 windows自带计算器快捷键win+r打开运行窗口 然后输入calc，确认 快捷键功能CTRL组合键 Ctrl + A ———— 全选 Ctrl + C ———— 复制 Ctrl + D ———— 网页收藏 Ctrl + F ———— 查找 Ctrl + C ———— 复制 Ctrl + N ———— 新窗口 Ctrl + R ———— 网页刷新 Ctrl + S ———— 保存 Ctrl + T ———— 打开新网页 Ctrl + V ———— 粘贴 Ctrl + W ———— 关闭当前窗口 Ctrl + X ———— 剪贴 Ctrl + Y ———— 恢复上一步操作 Ctrl + Z ———— 撤消上一步操作 F键 F1 ———— 帮助 F2 ———— 重命名 F3 ———— 搜索 F4 ———— 显示我的电脑和Windows 资源管理器中的地址栏列表。 F5 ———— 刷新 F6 ———— 在窗口或桌面上循环切换屏幕元素。 F7 ———— DoS下专用功能 F8 ———— Windows启动选项 F9 ———— Excel中计算公式 F10 ———— 激活菜单栏（当可用时） F11 ———— 切换全屏 F12 ———— Word 里另存文档 Win键 Win + D ———— 显示桌面 Win + E ———— 打开我的电脑 Win + F ———— 查找所以文件 Win + L ———— 锁屏 Win + M ———— 最小化窗口 Win + R ———— 运行命令 Win + U ———— 辅助工具 其它功能键 Delete ———— 删除 Shift + Delete ———— 永久删除所 Ctrl + shift + T ———— 恢复误删的网页 Alt + F4 ———— 关闭当前项目或者关闭计算机 Alt + Tab ———— 在打开的项目之间切换 Ctrl + Tab ———— 在选项卡之间向前移动 Ctrl + Shift + Tab ———— 在选项卡之间向后移动 转载标明出处或联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php连接Access数据库]]></title>
    <url>%2F2017%2F03%2F11%2Fphp-access%2F</url>
    <content type="text"><![CDATA[最近需要把PHP的网站连接数据库，无奈数据库是access。我们都知道，PHP+MySQL，asp+access数据库，然而PHP+access数据库我还真没连接过。我在网上找了一堆PHP+access数据库的连接方式，然而并没什么软用。最后还是让我找了一个，经过修改可以正常连接数据库了。 1234567891011121314151617181920// 编码格式header(&quot;Content-type: text/html; charset=utf-8&quot;);$connstr=&quot;DRIVER=&#123;Microsoft Access Driver (*.mdb)&#125;; DBQ=&quot; . realpath(&quot;你的数据库路径&quot;);$connid=odbc_connect($connstr,&quot;&quot;,&quot;&quot;,SQL_CUR_USE_ODBC);// sql语句$sql1=&quot;select top 1 * from KS_Article where Tid=&apos;20155258952919&apos; order by id desc&quot;;// 获取信息$result1=odbc_exec($connid,$sql1);$arr1=array();while($r = odbc_fetch_array($result1))&#123; foreach ($r as $key =&gt; $value) &#123; $r[$key]=mb_convert_encoding($value, &quot;utf-8&quot;,&quot;gbk&quot;); &#125; array_push($arr1,$r);&#125; 转载标明出处或联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>php</tag>
        <tag>access</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS文本、单词过长强制换行]]></title>
    <url>%2F2017%2F02%2F16%2FToolong%2F</url>
    <content type="text"><![CDATA[文本溢出省略显示因为网页排版的需要，有些地方需要过长的问题加上省略号。比如：标题限制20个中文的宽度，超出的就用省略号代替。之前会使用程序截取的方法，不过使用css来截取更有利于SEO。 首先实现单行缩略是可以通过下面的代码实现的（部分浏览器需要设置宽度）： 123overflow: hidden; /*内容会被修剪，并且其余内容是不可见的。*/text-overflow: ellipsis; /*截断文字，显示省略号(...)*/white-space: nowrap; /*文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止*/ WebKit内核浏览器解决办法首先，WebKit内核的浏览器实现起来比较简单，可以通过添加一个-webkit-line-clamp的私有属性来实现，-webkit-line-clamp是用来限制在一个块元素显示的文本的行数。 为了实现这个效果，它需要组合其他的WebKit属性： 具体代码参考如下： 12345overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical; 其他浏览器的解决方案目前没有什么CSS的属性可以直接控制多行文本的省略显示，比较靠谱的办法应该就是利用相对定位在最后面加上一个省略号了，代码可以参考下面： 123456789101112131415p&#123; position:relative; line-height:1.5em; /* 高度为需要显示的行数*行高，比如这里我们显示两行，则为3 */ height:3em; overflow:hidden;&#125;p:after&#123; content:&quot;...&quot;; position:absolute; bottom:0; right:0; padding: 0 5px; background-color: #fff;&#125; 扩展知识12345678910111213141516171819white-space: normal|pre|nowrap|pre-wrap|pre-line|inherit;white-space 属性设置如何处理元素内的空白normal 默认。空白会被浏览器忽略。pre 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签。nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。pre-wrap 保留空白符序列，但是正常地进行换行。pre-line 合并空白符序列，但是保留换行符。inherit 规定应该从父元素继承 white-space 属性的值。word-wrap: normal|break-word;word-wrap 属性用来标明是否允许浏览器在单词内进行断句，这是为了防止当一个字符串太长而找不到它的自然断句点时产生溢出现象。normal: 只在允许的断字点换行(浏览器保持默认处理)break-word:在长单词或URL地址内部进行换行word-break: normal|break-all|keep-all;word-break 属性用来标明怎么样进行单词内的断句。normal：使用浏览器默认的换行规则。break-all:允许再单词内换行keep-all:只能在半角空格或连字符处换行 转载标明出处或联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript对数组元素的基本操作]]></title>
    <url>%2F2017%2F01%2F05%2Farr%2F</url>
    <content type="text"><![CDATA[数组元素去重不使用ES7 1234567891011var arr = [1,2,3,4,5,6,7,7,1,8,8,9];var arr1=[];function repeat()&#123; for(var i=0;i&lt;arr.length;i++)&#123; if(arr1.indexOf(arr[i]) == -1)&#123; arr1.push(arr[i]); &#125; &#125; return arr1;&#125;console.log(repeat(arr1)); 使用ES7 1234567891011var arr = [1,2,3,4,5,6,7,7,1,8,8,9];var arr1=[];function repeat()&#123; for(var i=0;i&lt;arr.length;i++)&#123; if(arr1.includes(arr[i]) == 0)&#123; arr1.push(arr[i]); &#125; &#125; return arr1;&#125;console.log(repeat(arr1)); 数组元素最值最大值 123456789101112var arr = [1,2,3,4,5,6,7,7,1,8,8,9];function max()&#123; var max=arr[0]; for (var i = 0; i &lt; arr.length; i++) &#123; if(max&lt;arr[i])&#123; max=arr[i]; &#125; &#125; return max;&#125;console.log(max(max)); 最小值 12345678910function min()&#123; var min=arr[0]; for (var i = 0; i &lt; arr.length; i++) &#123; if(min&gt;arr[i])&#123; min=arr[i]; &#125; &#125; return min;&#125;console.log(min(min)); 数组元素排序123console.log(arr1.sort(function(a,b)&#123; return a-b;&#125;)) 数组元素的一些其它操作数组元素的字符串化 12var arr = [1,2,3,4,5,6,7,7,1,8,8,9];console.log(arr.join()); 两数组元素取不一样的元素 123var arr=[1,2,3];var arr2=[1];console.log(arr.slice(arr2)); 两数组元素合并 123var arr=[1,2,3];var arr2=[1];console.log(arr.concat(arr2)); 转载标明出处或联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSL/TLS 握手过程详解]]></title>
    <url>%2F2016%2F12%2F02%2FSSL-TLS%2F</url>
    <content type="text"><![CDATA[我们知道，HTTP 协议都是明文传输内容，在早期只展示静态内容时没有问题。伴随着互联网的快速发展，人们对于网络传输安全性的要求也越来越高，HTTPS 协议因此出现。如上图所示，在 HTTPS 加密中真正起作用的其实是 SSL/TLS 协议。SSL/TLS 协议作用在 HTTP 协议之下，对于上层应用来说，原来的发送接收数据流程不变，这就很好地兼容了老的 HTTP 协议，这也是软件开发中分层实现的体现。 SSL/TLS 握手是为了安全地协商出一份对称加密的秘钥，这个过程很有意思，下面我们一起来了解一下。 以下内容需要你对加解密、数字签名和数字证书的概念有一定了解，这里有一篇文章可以帮你快速了解这几个概念。 SSL/TLS 握手过程 上图大致描述了 SSL/TLS 的握手过程，但缺少了一些信息不利于理解，我会在后面的讲解里再列出来。 Client Hello握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 Random1、客户端支持的加密套件（Support Ciphers）和 SSL Version 等信息。通过 Wireshark 抓包，我们可以看到如下信息： Wireshark 抓包的用法可以参考这篇文章 Server Hello第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 Random2。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。 Certificate这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。 Server Key Exchange如果是DH算法，这里发送服务器使用的DH参数。RSA算法不需要这一步。 Certificate RequestCertificate Request 是服务端要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到。 Server Hello DoneServer Hello Done 通知客户端 Server Hello 过程结束。 Certificate Verify客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 Random3，再用服务端公钥非对称加密 Random3 生成 PreMaster Key。 Client Key Exchange上面客户端根据服务器传来的公钥生成了 PreMaster Key，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 PreMaster Key 得到客户端生成的 Random3。至此，客户端和服务端都拥有 Random1 + Random2 + Random3，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。客户端将 PreMaster Key 传给服务端的过程如下图所示： Change Cipher Spec(Client)这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息。 Encrypted Handshake Message(Client)这一步对应的是 Client Finish 消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。 Change Cipher Spec(Server)这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。 Encrypted Handshake Message(Server)这一步对应的是 Server Finish 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。 Application Data到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。 双向验证前面提到 Certificate Request 是可选的，下面这张图展示了双向验证的过程： 握手过程优化如果每次重连都要重新握手还是比较耗时的，所以可以对握手过程进行优化。从下图里我们看到 Client Hello 消息里还附带了上一次的 Session ID，服务端接收到这个 Session ID 后如果能复用就不再进行后续的握手过程。 除了上述的 Session 复用，SSL/TLS 握手还有一些优化技术，例如 False Start、Session Ticket 等，这方面的介绍具体可以参考这篇文章。 总结前面我们一起详细地了解了整个 SSL/TLS 的握手过程，这部分知识在平时的开发过程中很少用到，但能让我们更清楚地了解 HTTPS 的工作原理，而不仅仅是只知道 HTTPS 会加密数据十分安全。同时这个过程也是各种加密技术的一个经典运用，也能帮助我们加深加密相关技术的理解。最后，建议大家也用 Wireshark 实际抓包体验一下这个过程来加深印象，enjoy~ 参考资料http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html https://segmentfault.com/a/1190000002554673 https://imququ.com/post/optimize-tls-handshake.html http://blog.csdn.net/fw0124/article/details/40983787 作者：hi_xgb 来自：https://gold.xitu.io/post/584b76d3a22b9d0058d5036f]]></content>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb操作]]></title>
    <url>%2F2016%2F11%2F27%2Fmongodb%2F</url>
    <content type="text"><![CDATA[一、什么是MongoDB？1、MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器的性能。 2、MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。 3、MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 二、数据库&amp;规范1、一个mongodb中可以建立多个数据库。 2、MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。 3、规范： 1.不能是空字符串（””)。 2.不得含有’ ‘（空格)、.、$、/、\和\0 (空宇符)。 3.应全部小写。 4.最多64字节。 4、有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。 文档&amp;集合文档是mongodb中的最核心的概念，是其核心单元，我们可以将文档类比成关系型数据库中的每一行数据。 集合就是一组文档的组合。如果将文档类比成数据库中的行，那么集合就可以类比成数据库的表。在mongodb中的集合是无模式的，也就是说集合中存储的文档的结构可以是不同的，比如下面的两个文档可以同时存入到一个集合中： {“name”:”mingge”} {“Name”:”mingge”,”sex”:”man”} 注：当第一个文档插入时，集合就会被创建。 合法的集合名 集合名不能是空字符串””。 集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。 集合名不能以”system.”开头，这是为系统集合保留的前缀。 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统 终端启动首先需要指定数据库的地址 mongod —dbpath=数据库地址 再在终端键入./mongo 打开shell编程脚本 操作MongoDB基础1.创建数据库 use database_name database_name代表数据库的名字 注：如果数据库不存在，则创建数据库，否则切换到指定数据库 2.查看所有数据库 show dbs 3.数据的 增删改查 //增加 db.collection_name.insert() //删除 db.collection_name.remove() //更新（修改） db.collection_name.update() //查找 db.collection_name.find() 总结 MongoDB —— 是一个对象数据库，没有表、行等概念，也没有固定的模式和结构，所有的数据以Document(以下简称文档)的形式存储(Document，就是一个关联数组式的对象，它的内部由属性组成，一个属性对应的值可能是一个数、字符串、日期、数组，甚至是一个嵌套的文档。) 文档 —— 是MongoDB的核心概念，是键值对的一个有序集，在JavaScript里文档被表示成对象。同时它也是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行，但更具表现力。 转载标明出处或联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mySQL基础语法-增删改查]]></title>
    <url>%2F2016%2F11%2F20%2FmySQL%2F</url>
    <content type="text"><![CDATA[1、增加12INSERT INTO 表的名字(字段一,字段二,字段三) VALUES (&quot;值一&quot;,&quot;值二&quot;,&quot;值三&quot;);INSERT INTO users(username,pwd,age) VALUES (&quot;YANG&quot;,&quot;43214321&quot;,&quot;43&quot;); 2、删除12345DELETE FROM 表的名字 WHERE username=&quot;张三&quot;;DELETE FROM 表的名字 AND username=&quot;张三&quot;;DELETE FROM 表的名字 OR username=&quot;张三&quot;;DELETE FROM 表的名字 NOT username=&quot;张三&quot;;DELETE FROM 表的名字 IN username=&quot;张三&quot;; 3、修改UPDATE 表的名字 SET 设置的内容 WHERE 条件语句; 4、查询12345SELECT 字段 FROM 表头 WHERE 条件语句(username=&quot;张三&quot; AND id&gt;2);SELECT * FROM users WHERE id&gt;2 LIMIT 2,1; // 条件ID大于二的 LIMIT开始从第二个数据开始查询一个SELECT * FROM users LIMIT 2,2; // 从第二个数据开始查询两个SELECT * FROM users ORDER BY id DESC // 倒叙排列的查询SELECT * FROM users ORDER BY id ASC; // 正序排列的查询 5、联表查询:将两张表联起来进行查询1234SELECT * FROM 表名1 JOIN 表名2 ON 条件;SELECT * FROM users AS u JOIN product AS P ON u.id=p.id;SELECT * FROM product LEFT JOIN users ON users.id=product.id;SELECT users.id,users.username,product.name FROM users LEFT JOIN product ON users.id=product.id; 转载标明出处或联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>语法</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始用gulp]]></title>
    <url>%2F2016%2F11%2F17%2Fgulp%2F</url>
    <content type="text"><![CDATA[gulp是基于流的前端构件化工具。目前比较火的前端构建化工具还是挺多的，grunt gulp fis3等等。 这个鬼东西有什么用？请参考https://www.zhihu.com/question/35595198 为什么选择gulp,因为使用非常简单，学习成本低。以后想用别的工具再转去学也不难。 一个自动化构建工具都没用过的前端，何以谈人生？以下是正题： 要玩gulp,首先得安装node,因为npm跟随node的包安装管理工具。具体下载直接百度nodejs中文网，根据自身的环境（windows linux mac）下载安装包（msi）。直接进行傻瓜式安装。 安装完node后开始全局安装gulp, 在命令行输入命令npm install -g gulp,安装成功后就可以在命令行输入gulp相关的命令了，例如gulp -v查看当前版本号。（npm安装不成功建议在命令前加sudo 或将 npm 换 cnpm 再试试） 在项目中安装npm install –save-dev gulp，安装成功后就可以开始写配置文件了。 在项目根目录中创建文件gulpfile.js 以下是简单的gulpfile.js demo代码 代码这种东西一开始不会写，就先抄，抄着抄着就懂怎么写了。 12345678910111213141516171819//引入插件var gulp = require(&apos;gulp&apos;);var less = require(&apos;gulp-less&apos;);//需要npm install --save-dev gulp-lessvar paths = [&apos;./css/*.less&apos;]; //定义一个数组，指定文件路径//下面开始编写一个任务//less编译任务 gulp.task(&apos;less&apos;, function() &#123; //创建一个gulp任务，任务名字是&apos;less&apos;，然后一个回调函数 return gulp.src(paths) //gulp任务操作的源文件&apos;paths&apos; .pipe(less()) //执行less编译 .pipe(gulp.dest(&apos;./css&apos;)); //gulp任务输出的新文件&#125;);//watch监听任务gulp.task(&apos;watch&apos;, function()&#123; //创建第二个gulp任务，任务名字是‘watch&apos;,然后一个回调函数 gulp.watch(paths,[&apos;less&apos;]); //gulp的watch监听，文件改动后立即重新执行less任务 可参考http://www.gulpjs.com.cn/docs/api/&#125;);//gulp.watch(&apos;default&apos;,[&apos;less&apos;]);gulp.task(&apos;default&apos;, [&apos;less&apos;,&apos;watch&apos;]); //gulp的default任务，相当于glup的执行入口。然后把less任务和watch放进来，该脚本就会执行这两个任务 把以上代码写入gulpfile.js 后保存，然后项目根路径下执行命令 gulp 就开始执行gulp完成你安排的任务。 日常开发中需要gulp做的有很多如合并文件（gulp-concat）压缩（gulp-uglify）重命名（gulp-rename）等等。 这就需要自己编写task来让gulp来执行。 最后总结一下，写好一个gulpfile.js很简单，结合demo代码和下面五个命令 123456789gulp.task(name, fn)//新建一个gulp任务，name是任务名，fn回调函数gulp.run(tasks...)//尽可能多的并行运行多个task 新版本中的gulp中使用run会发出警告，这样的情况下我们可以用start代替gulp.watch(glob, fn//)当glob内容发生改变时，执行fngulp.src(glob)//返回一个可读的streamgulp.dest(glob)//返回一个可写的stream gulp官方网址：http://gulpjs.com gulp插件地址：http://gulpjs.com/plugins 最后简单写就几个常用的gulp task，方便日后调用 一、压缩css 123456var minifycss = require(&apos;gulp-minify-css&apos;);//引用插件，需npm install --save-dev gulp-minify-cssgulp.task(&apos;minifycss&apos;, function() &#123;return gulp.src(&apos;src/css/*.css&apos;) //压缩的文件.pipe(minifycss()) //执行压缩.pipe(gulp.dest(&apos;dst/css&apos;)); //输出文件夹&#125;); 二、压缩js 123456789101112131415161718192021var concat = require(&apos;gulp-concat&apos;), uglify = require(&apos;gulp-uglify&apos;), rename = require(&apos;gulp-rename&apos;); //引用插件，需npm install --save-dev xxxxxxgulp.task(&apos;minifyjs&apos;, function() &#123; return gulp.src(&apos;src/*.js&apos;) //操作的源文件 .pipe(concat(&apos;main.js&apos;)) //合并所有js到main.js .pipe(gulp.dest(&apos;minified/js&apos;)) //输出main.js到文件夹 .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) //rename压缩后的文件名 .pipe(uglify()) //压缩 .pipe(gulp.dest(&apos;minified/js&apos;)); //输出&#125;); 三、清空输出目录 1234var del =require(&apos;del&apos;);gulp.task(&apos;clean&apos;, function() &#123; return del([&apos;dst&apos;]); //&apos;dst&apos;是一个目录&#125;); 四、压缩图片 1234567const imagemin = require(&apos;gulp-imagemin&apos;); gulp.task(&apos;default&apos;, function()&#123; return gulp.src(&apos;src/images/*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;dist/images&apos;));&#125;); 五、压缩html 123456789101112131415161718var gulp = require(&apos;gulp&apos;), htmlmin = require(&apos;gulp-htmlmin&apos;); gulp.task(&apos;htmlMin&apos;, function () &#123; var options = &#123; removeComments: true,//清除HTML注释 collapseWhitespace: true,//压缩HTML collapseBooleanAttributes: true,//省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true,//删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true,//删除&lt;script&gt;的type=&quot;text/javascript&quot; removeStyleLinkTypeAttributes: true,//删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot; minifyJS: true,//压缩页面JS minifyCSS: true//压缩页面CSS &#125;; gulp.src(&apos;src/*.html&apos;) .pipe(htmlmin(options)) .pipe(gulp.dest(&apos;dst&apos;));&#125;); 六、合并文件 1234567var concat = require(&apos;gulp-concat&apos;); gulp.task(&apos;concat&apos;, function () &#123; gulp.src(&apos;src/js/*.js&apos;) .pipe(concat(&apos;all.js&apos;))//合并后的文件名 .pipe(gulp.dest(&apos;dist/js&apos;));&#125;); 七、css自动处理浏览器前缀,如添加-webkit-解决浏览器兼容问题 1234567var autoprefixer = require(&apos;gulp-autoprefixer&apos;); gulp.task(&apos;autoprefixer&apos;, function () &#123; gulp.src(&apos;css/index.css&apos;) .pipe(autoprefixer()) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;); 作者：覃 来自：http://www.cnblogs.com/BillyQin/p/6130440.html]]></content>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hack-css]]></title>
    <url>%2F2016%2F11%2F13%2Fhack-css%2F</url>
    <content type="text"><![CDATA[之前一直很狭隘的对CSS hack持有偏见，觉得写得规范的代码不应该使用这些“邪门歪道”，可最近产品发布一个小问题却让我头疼了很久，最后查了一下资料，竟然使用CSS hack轻松解决了，不得不服啊，对付神奇的IE就得使用这些利器。 什么是CSS hack由于不同的浏览器，甚至同一浏览器的不同版本对CSS的解析认识不一样，导致生成的页面效果不一致，写出针对不同浏览器CSS code就称为CSS hack。 常用的CSS hack 有三种方式，CSS 内部hack、选择器hack、HTML 头部引用，其中第一种最常用。 CSS 内部hack正经的CSS是这么写的 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Test&lt;/title&gt; &lt;style type=&quot;text/css&quot; &gt; .test &#123; background-color:green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;test&quot; style=&quot;height:100px; width:100px; line-height:100px; margin:50px; border:1px solid #000;&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;html&gt; 这样的代码对于所有当前常用的浏览器都是好使的，结果应该是这样子的 但是在CSS3中常见一些这样的写法 12345678910/*Mozilla内核浏览器：firefox3.5+*/ -moz-transform: rotate | scale | skew | translate ; /*Webkit内核浏览器：Safari and Chrome*/ -webkit-transform: rotate | scale | skew | translate ; /*Opera*/ -o-transform: rotate | scale | skew | translate ; /*IE9*/ -ms-transform: rotate | scale | skew | translate ; /*W3C标准*/ transform: rotate | scale | skew | translate ; 如果没有注释乍一看还以为逆天了，这样的代码都好使！这样的代码确实好使，CSS3目前标准还没有统一，各个浏览器都有自己的表现方式，甚至有的实现，有的未实现，在前面加一些前缀以表示支持某个特定浏览器，这也是CSS 内部hack的基本原理，向上面这些简单易懂，但是真正的CSS hack 远远不止于此，因为有不死的IE6及其各种奇葩的兄弟版本。 CSS 内部hack 语法是这样的 selector{?property:value?;} ，上面代码所示的是在属性名称之前的hack，当然还有这样的 *background-color:green; 属性前面加个“*”这样的写法只会对IE6、7生效，其它版本IE及现代浏览器会忽略这条指令（没有特殊说明，本文所有hack都是指在声明了DOCTYPE的文档的效果） -background-color:green; 属性前面有个“-”这样的只有IE6识别，还有些在后面的hack background-color:green!important; 这样在属性值后面添加“!important”的写法只有IE6不能识别，其它版本IE及现代浏览器都可以识别，还有“+”、“\0”、”\9” 等，乱七八糟好烦，画个表 hack IE6 IE7 IE8 IE9 IE10 现代浏览器 * 👍 👍 + 👍 - 👍 !important 👍 👍 👍 👍 👍 \9 👍 👍 👍 👍 👍 \0 👍 👍 👍 \9\0 👍 👍 这样就清楚多了吧。如果只想给上面的test DIV在IE访问的时候加绿色背景，就可以这么写 background-color:green\9; 如果想IE6红色，IE7绿色，其它黄色（当然没人这么无聊）就可以这么写 background-color:green; +background-color:green; _background-color:green; 选择器hack选择器hanck主要是针对IE浏览器，其实并不怎么常用，语法是这样的： selector{ sRules } hack IE6 IE7 IE8 IE9 IE10 现代浏览器 *html 👍 *+html 👍 :root 👍 针对IE9的hack可以这么写 :root .test { background-color:green; } HTML头部引用HTML头部引用就比较特殊了，类似于程序语句，只能使用在HTML文件里，而不能在CSS文件中使用，并且只有在IE浏览器下才能执行，这个代码在非IE浏览下非单不是执行该条件下的定义，而是当做注释视而不见。 12345678910&lt;!– 默认先调用css.css样式表 –&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css.css&quot; /&gt;&lt;!–[if IE 7]&gt;&lt;!– 如果IE浏览器版是7,调用ie7.css样式表 –&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie7.css&quot; /&gt;&lt;![endif]–&gt;&lt;!–[if lte IE 6]&gt;&lt;!– 如果IE浏览器版本小于等于6,调用ie.css样式表 –&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie.css&quot; /&gt;&lt;![endif]–&gt; lte：就是Less than or equal to的简写，也就是小于或等于的意思。 lt ：就是Less than的简写，也就是小于的意思。 gte：就是Greater than or equal to的简写，也就是大于或等于的意思。 gt ：就是Greater than的简写，也就是大于的意思。 ! ：就是不等于的意思，跟javascript里的不等于判断符相同。 书写顺序看看，看看，这么多姿势，那么一个效果，好多种写法，什么顺序写才能保证各个浏览器都得到希望的效果呢？因为CSS只要是同一级别，出现重复属性设置，后出现的会覆盖前面出现的，所以在书写的时候一般把识别能力强的写前面，看个例子 _background-color:red; background-color:green; 如果希望DIV在IE6上是红色，其它是绿色，上面的写法可不可以呢？试一下发现所有浏览器上都是绿色，因为在IE6解析的时候，第一句能够识别，背景设为红色，但是第二句所有浏览器都识别，IE6也不例外，背景颜色又被设为绿色，所以得反过来写 background-color:green; _background-color:red; 总结出的规律就是：先一般，再特殊。有兴趣的同学可以试试试试下面CSS，看看和你想的效果是否一样 background-color:blue; /*所有浏览器*/ background-color:red\9;/*所有的ie*/ background-color:yellow\0; /* ie8+*/ +background-color:pink; /*+ ie7*/ 作者：Samaritans 来自：http://www.cnblogs.com/dolphinX/p/3292630.html]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个页面之间如何进行通信之cookie篇]]></title>
    <url>%2F2016%2F11%2F09%2Fcookie-com%2F</url>
    <content type="text"><![CDATA[如何解决浏览器多个标签页之间的通信? 使用cookie 使用web worker 使用localeStorage和sessionStorage cookie 概念 cookie简单理解就是一种可以让服务器在客户端的硬盘或者内存里面存储少量数据,或者说从客户端硬盘读取数据的技术. cookie的存放形式 cookie的信息是以名/值形式保存,一个名/值仅仅是一条信息 cookie保存位置 window7是C:\Users\Administrator\Cookies，隐藏文件(.txt). cookie的功能 多用来记录用户的个人信息.毕竟HTTP是无状态的协议. cookie的工作原理 用户在浏览器输入url,发送请求,服务器接受请求 服务器在响应报文中生成一个Set-Cookie报头,发给客户端 浏览器取出响应中Set-Cookie中内容,以cookie.txt形式保存在客户端 如果浏览器继续发送请求,浏览器会在硬盘中找到cookie文件,产生Cookie报头,与HTTP请求一起发送. 服务器接受含Cookie报头的请求,处理其中的cookie信息,找到对应资源给客户端. 浏览器每一次请求都会包含已有的cookie. 图解基本的cookie知识点 cookie 是有大小限制的 每一个cookie都是合法格式的名值对 cookie是有有效期的(Expires) cookie有domain域的概念,不同的域是不能进行访问的.可以通过设置document.domain来实现一些跨域. cookie中的path路径,一个页面产生的cookie只能被与这个页面的同一目录或者是其子目录下的页面访问(同源策略). cookie的两种形式 短暂性的：浏览器关闭后或者页面关闭后就删除cookie 具有有效期的(设置了有效时间),浏览器关闭依然存在硬盘 js操作cookie 获取cookie 12console.log(document.cookie)//&quot;r_user_id=f7aae2bb-6810-4ec9-b4c7-fbf2fe1e0738; PHPSESSID=web4~7rgfe5mbsjam50en9sujerd085;&quot; 对cookie进行存/改 12document.cookie=&apos;key=value&apos;//key存在就修改为value,不存在就创建 读取对应的cookie值 12345678910111213var getCookie = function( keyName)&#123; var items = [] , json = &#123;&#125;; var cookie = document.cookie; if( cookie.length &gt; 0 )&#123; items = cookie.split(&apos;;&apos;); for(var i = 0;i &lt; items.length;i++)&#123; json[items[i].split(&apos;=&apos;)[0]] = items[i].split(&apos;=&apos;)[1] ; &#125; return unescape(json[keyName]); &#125;else&#123; return &apos;&apos;; &#125;&#125; cookie有效期的设置 1234567891011121314151617//第一种function setCookie(c_name, value, expiredays)&#123; var exdate=new Date();//生成当天一个时间 exdate.setDate(exdate.getDate() + expiredays);//获取当天时间的天数+有效期天数 document.cookie=c_name+ &quot;=&quot; + escape(value) + ((expiredays==null) ? &quot;&quot; : &quot;;expires=&quot;+exdate.toGMTString()); //设置cookie &#125;//第二种function setCookie(cname, cvalue, exdays) &#123; var d = new Date(); d.setTime(d.getTime() + (exdays*24*60*60*1000)); var expires = &quot;expires=&quot;+d.toUTCString(); document.cookie = cname + &quot;=&quot; + cvalue + &quot;; &quot; + expires;&#125;``原理都是一样:格式不同.- 删除cookie(设置有效时间过期) //删除cookiesfunction clearCookie(name) {setCookie(name, “”, -1);} //删除cookiesfunction delCookie(name){var exp = new Date();exp.setTime(exp.getTime() - 1);var cval=getCookie(name);if(cval!=null)document.cookie= name + “=”+cval+”;expires=”+exp.toGMTString();} 123代码不放在服务器在chrome浏览器下不能处理cookie貌似 &gt; cookie的路径访问原则 默认情况下，只有与创建了cookie 的页面在同一个目录或子目录下的网页才可以访问这个cookie. www.csdn.cn/blog/a.html 创建了cookie www.csdn.cn/blog/b.html 就可以访问这个cookie页(同一目录) www.csdn.cn/blog/xyz/c.html 也可以访问这个cookie页(字目录) www.csdn.cn/xx/d.html 就不可以访问 12如何跨域这个障碍呢?原理:设置cookie到一个更高一级别的目录下(前面那个例子就可以把path=&apos;/&apos;) document.cookie = “name=value;expires=date;path=path” 1最常用的例子就是让 cookie 在根目录下,这样不管是哪个子页面创建的 cookie，所有的页面都可以访问到了 document.cookie = “key=value;path=/“ 123&gt; cookie的域引出这个话题是因为,设置path只能解决同域下的cookie访问问题.不同域的cookie怎么访问?www.csdn.cn 与 qq.csdn.cn ,如果后者想访问前者的cookie. 就要让www.csdn.cn这么设置 document.cookie = ‘key = value;path=/;domain=csdn.cn’ cookie的编码格式 在对cookie设置读取时候记得处理编码问题 作者：YiZong Xu 来自：https://1657413883.github.io/2016/11/27/%E5%A4%9A%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1/]]></content>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jade安装使用方法]]></title>
    <url>%2F2016%2F10%2F27%2Fjade%2F</url>
    <content type="text"><![CDATA[jade是一款基于haml的html模板引擎，采用Javascript实现，可以方便的在Node.js、Yeoman等框架中使用。文档[官方网站]（https://pugjs.org/api/getting-started.html） 安装在Node中安装Jade的方法如下： npm install jade -g jade -h 在Yeoman中,安装及配置过程较为复杂，具体方法请参看文档（http://blog.csdn.net/minchina91/article/details/38419093） 命令行使用12345678910111213141516171819202122232425262728293031选项:-h, --help 输出帮助信息-v, --version 输出版本号-o, --out &lt;dir&gt; 输出编译后的 HTML 到 &lt;dir&gt;-O, --obj &lt;str&gt; JavaScript 选项-p, --path &lt;path&gt; 在处理 stdio 时，查找包含文件时的查找路径-P, --pretty 格式化 HTML 输出-c, --client 编译浏览器端可用的 runtime.js-D, --no-debug 关闭编译的调试选项(函数会更小)-w, --watch 监视文件改变自动刷新编译结果Examples:# 编译整个目录$ jade templates# 生成 &#123;foo,bar&#125;.html$ jade &#123;foo,bar&#125;.jade# 在标准IO下使用jade $ jade &lt; my.jade &gt; my.html# 在标准IO下使用jade, 同时指定用于查找包含的文件$ jade &lt; my.jade -p my.jade &gt; my.html# 在标准IO下使用jade $ echo &quot;h1 Jade!&quot; | jade# foo, bar 目录渲染到 /tmp$ jade foo bar --out /tmp 注释单行注释// hello world 效果为： &lt;!-- hello world --&gt; 多行注释body // p hello world 效果为： &lt;body&gt; &lt;!--p hello world --&gt; &lt;/body&gt; 不输出注释在单行注释上加一个短横线- //- 这段注释不会输出 p hello world 效果为： &lt;p&gt;hello world&lt;/p&gt; 单行注释// hello world 效果为： &lt;p&gt;hello world&lt;/p&gt; 静态语法在本文中，将会介绍如何用简单的Jade模版语言来生成所需的HTML代码，可以极大减少代码量和提高可读性。 Jade同时具有很多的动态语言特性，本文中不详细涉及。 首先，我们来对比一下xml和json的特性，xml一个很大的缺点就是需要2倍的标签以及4倍的尖括号，虽然机器能够有效识别但十分不便于书写。另外，xml标签这样成对出现也同时增加了错误率，降低了可读性。所以现在越来越多的人用json而非传统的xml。 同样的，html和xml的语法非常相似，缺点也是非常相似，所以这里我们来介绍一种新的更为简洁清晰的模版语言 —— Jade。 第一步，我们来了解一下jade的基本静态语法部分。 对于一个经典的html代码如下： 123456789101112131415161718192021222324252627282930&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;Jade&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Jade - node template engine&lt;/h1&gt; &lt;div id=&quot;container&quot; class=&quot;col class1 class2&quot;&gt; &lt;p&gt;You are amazing&lt;/p&gt; &lt;p&gt; Jade is a terse and simple templating language with a strong focus on performance and powerful features. &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;我们也可以用jade来写：html(lang=&quot;en&quot;) head title= pageTitle body h1 Jade - node template engine #container.col.class1.class2 p You are amazing p. Jade is a terse and simple templating language with a strong focus on performance and powerful features. 通过上面的例子，相信大家都能很快了解Jade的语法模式，主要概括一下有以下几点： 标签名称不变，无需使用尖括号 &lt; &gt; 围绕。 标签不具有嵌套性，使用缩进来表示嵌套关系，每级缩进相当于一层嵌套。 使用标签名称后#someid来表示id属性，无需再使用属性名id＝‘someid’。 使用标签名称后.someclass来表示class属性，多个class可连续使用。 对于带有id或class属性的div标签，可以省略div不写。 对于其他属性，在标签名后使用括号( )来围绕，与html的标签属性使用方式相同，也可用逗号分隔。 在标签名称和所有属性后使用一个空格来分隔其文本内容，即从每个标签名称开始第一个不在属性内的空格之后的内容都将识别为文本。 对于多行文本，在标签的所有属性之后使用单独的.，其下级缩进的内容都将视为文本。 掌握上面的内容基本就已经可以用Jade来写代码了，不过接下来还是说一下其他的一些语法。 对于嵌套来说，除了使用上面的缩进方法外，如果是只有一个子元素，可以使用:来实现嵌套。例如： ul#books li a(href=&quot;#book-a&quot;) Book A li a(href=&quot;#book-b&quot;) Book B 该列表中，由于每个li下都只有一个a标签，故也可写作： ul#books li: a(href=&quot;#book-a&quot;) Book A li: a(href=&quot;#book-b&quot;) Book B 注意：冒号后面一定要有一个空格！ 对于多行文本，如果同时具有子元素的话，使用.会导致无法识别子元素，故需要使用另一种标识符|，例如： ul#books p | foo bar | hello world p 这是子元素而非另一行文字 当然，这样的缺点就是对于多行文字的每一行都要有一个|。 动态特性到上面为止，似乎Jade相对于haml都没有什么实质性改变，只是对于html的一种简化方式，使用很多编译器插件也可以实现类似的简化书写能力。而实际上，Jade远不仅仅是一种静态语言，它同时也能实现很多需要脚本语言才能实现的动态特性，比如赋值、循环、判断等等。 在任何一门动态语言中，变量是永远不可或缺的，这也是和标记性语言的根本区分标识。 在Jade中，使用和C系语言相似的方式进行赋值和运算： foo = &quot;hello&quot; tmp = &quot;world&quot; + &quot;!&quot; h1= foo span= tmp 对于上面的代码，可能很多人第一眼看到都会有一个疑问，Jade怎么知道等号左边是变量名还是标签呢？ 再仔细看看，很快就会发现，又是传说中的空格在作祟，变量后面等号前必须加空格，而标签直接接等号，不能加空格！ 其实Jade中还有另一种赋值语句，用的不是=而是!=。这里可能会有一些凌乱，!=不是条件语句中的不等于逻辑运算符么？在Jade中，!=确实是不等于的逻辑运算符。但是在对标签的赋值中，也就像上面的一样不加空格的赋值语句中，它表示另一种赋值理念： name ＝ &quot;Hello &lt;em&gt;World&lt;/em&gt;&quot; li= name li!= name 生成的html代码为： &lt;li&gt;Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;&lt;/li&gt; &lt;li&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/li&gt; 从上面可以看出，使用=会直接赋予纯文本而非html代码，如果需要产生的值是直接html代码的话，需要使用!=来防止转换！ 补充一点，除了在Jade文件中对变量赋值，Jade还支持在编译时对变量赋值的特性，区别在于变量从模版中分离，从而可以在动态赋予相应的内容。 接下来，我们来稍微接触一下Jade的流程控制语句： 1234books ＝ [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] select each book, i in books option(value=i) Book #&#123;book&#125; 上面可以生成具有类似结构的多个option： 12345&lt;select&gt; &lt;option value=&quot;0&quot;&gt;Book A&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;Book B&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;Book C&lt;/option&gt;&lt;/select&gt; 除此之外，还有if-else,unless-else,case-when等条件控制语句，此处不做详述，如有需要可以访问官方文档。 就工程上来说，这些内容可能真的用不到或者不会用的。Jade的动态特性是根据条件动态的生成对应的HTML，而目前来说，因为JavaScript的存在，HTML本身就已经是动态的了，而且这些动态过程大多并不是在编译成HTML时能够确定的，而是在用户浏览HTML的过程中实时确定；相反，需要在Jade编译成HTML进行逻辑判断的东西，也都能直接通过JavaScript的动态特性来实现，特别是现在已经有了各种各样的JavaScript框架。 虽然Jade在设计上考虑了很多方面，不过对于我们开发人员来说最需要的可能还是其对HTML本身的语法简化部分，Jade的动态特性部分建议不要滥用。]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>安装</tag>
        <tag>语法</tag>
        <tag>jade</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底掌握this,call,apply]]></title>
    <url>%2F2016%2F10%2F23%2Fthis-call-apply%2F</url>
    <content type="text"><![CDATA[说起js里面比较头疼的知识点,this的指向,call与apply的理解这三者肯定算的上前几,好的js开发者这是必须迈过的槛.今天就总结下这三者紧密相连的关系. 首先推荐理解call的用法 Function.prototype.call 格式:fx.call( thisArg [，arg1，arg2，… ] ); call的传参个数不限,第一个数表示调用函数(fx)函数体内this的指向.从第二个参数开始依次按序传入函数. 123456789101112131415var age = 40;var xiaoMing = &#123; age:30&#125;;var xiaoLi = &#123; age: 20&#125;;var getAge = function()&#123; console.log(this.age);&#125;; getAge.call( xiaoMing ); //30 表示函数this指向xiaoMinggetAge.call(xiaoLi); //20 表示函数this指向xiaoLigetAge.call(undefined);//40 getAge.call(undefined)==getAge.call(null)getAge.call(null);//40getAge(); //40 如果我们传入fx.call()的第一个参数数为null,那么表示函数fx体内this指向宿主对象,在浏览器是Window对象,这也解释了getAge.call(undefined);//40。 在此基础我们可以理解为 getAge()相当于getAge.call(null/undefined),扩展到所有函数, fx()==fx.call(null) == fx.call(undefined) 值得注意的是严格模式下有点区别: this指向null 12345var getAge = function()&#123; &apos;use strict&apos; console.log(this.age);&#125;;getAge(null);//报错 age未定义 再来理解this的使用 this的常用场景: this位于一个对象的方法内,此时this指向该对象 123456789var name = &apos;window&apos;;var Student = &#123; name : &apos;kobe&apos;, getName: function () &#123; console.log(this == Student); //true console.log(this.name); //kobe &#125;&#125;Student.getName(); this位于一个普通的函数内,表示this指向全局对象,(浏览器是window) 123456var name = &apos;window&apos;;var getName = function () &#123; var name = &apos;kobe&apos;; //迷惑性而已 return this.name;&#125;console.log( getName() ); //window this使用在构造函数(构造器)里面,表示this指向的是那个返回的对象. 1234567var name = &apos;window&apos;;//构造器var Student = function () &#123; this.name = &apos;student&apos;;&#125;var s1 = new Student();console.log(s1.name); //student 注意: 如果构造器返回的也是一个Object的对象(其他类型this指向不变遵循之前那个规律),这时候this指的是返回的这个Objec. 12345678910var name = &apos;window&apos;;//构造器var Student = function () &#123; this.name = &apos;student&apos;; return &#123; name: &apos;boyStudent&apos; &#125;&#125;var s1 = new Student();console.log(s1.name); //boyStudent this指向失效问题 12345678910var name = &apos;window&apos;;var Student = &#123; name : &apos;kobe&apos;, getName: function () &#123; console.log(this.name); &#125;&#125;Student.getName(); // kobevar s1 = Student.getName;s1(); //window 原因: 此时s1是一个函数 123function () &#123; console.log(this.name); &#125; 对一个基本的函数,前面提过this在基本函数中指的是window. 在开发中我们经常使用的this缓存法 ,缓存当前作用域下this到另外一个环境域下使用 最后理解apply的用法 Function.prototype.apply 格式: fx.apply(thisArg [，argArray] ); // 参数数组，argArray apply与call的作用是一样的,只是传参方式不同, apply接受两个参数,第一个也是fx函数体内this的指向,用法与call第一个参数一致.第二个参数是数组或者类数组,apply就是把这个数组元素传入函数fx. 1234var add = function (a ,b ,c) &#123; console.log(a +b +c);&#125;add.apply(null , [1,2,3]); // 6 再吃透这个题目就ok 12345678910111213141516var a=10;var foo=&#123; a:20, bar:function()&#123; var a=30; return this.a; &#125;&#125;foo.bar()//20(foo.bar)()//20(foo.bar=foo.bar)()//10(foo.bar,foo.bar)()//10 作者：YiZong Xu 来自：https://1657413883.github.io/2016/11/22/%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1this-call-apply/]]></content>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动WEB像素相关知识]]></title>
    <url>%2F2016%2F10%2F20%2Fmobile-px%2F</url>
    <content type="text"><![CDATA[移动WEB像素相关知识了解移动web像素的知识，主要是为了切图时心中有数。本文主要围绕一个问题：怎样根据设备厂商提供的屏幕尺寸和物理像素得到我们切图需要的逻辑像素？围绕这个问题以iphone5为例讲解涉及到的web像素相关知识。 一、前置知识1、 iphone5的相关参数 iPhone5 参数 处理器 苹果A6处理器，1.3Ghz 屏幕 四英寸1136 × 640 Retina Display 主摄像头 800万像素 前置摄像头 120万像素 闪存 16GB 32GB 64GB 机身 前钢化玻璃面板，后混合面板+金属边框 手机尺寸 123.8×58.6×7.6mm 网络支持 2G：GSM 850/900/1800/1900 3G：CDMA EV-DO rev.A WCDMA 850/900/1900/2100 中国移动2G 中国联通2G/3G/4G(美版v版支持电信3G) 2、勾股定理：直角三角形，2直角边的平方和等于斜边的平方！ 二、像素相关名词和名词之间的关系1、px,dp和dprpx:css pixels 逻辑像素，浏览器使用的抽象单位【切图用逻辑像素】 dp:device independent pixels 设备无关像素，即物理像素 【设备厂商会提供物理像素】 dpr：devicePixelRatio设备像素缩放比 【处理物理像素和逻辑像素的关系，具体换算关系后面再讲】 2、DPI和PPIDPI:打印机每英寸可以喷的墨汁点（印刷行业） PPI:即Pixels per inch，屏幕每英寸的像素数量，即单位英寸内的像素密度 在计算机显示设备参数描述上，二者意思一致。 PPI越高，像素数越高，图像越清晰 2.1PPI和默认缩放比DPR的关系 Retina屏（高清屏）：dpr都是大于等于2 由对应关系可以看出，PPI越高，系统默认设置缩放比越大，可视度越低（小）。 2.2计算iphone5的PPI由前置知识能得知iphone5的像素信息：四英寸1136 × 640 Retina Display 首先根据勾股定理计算出iphone5手机屏幕的对角线等效像素，然后除以对角线(4英寸)，就得到PPI为326. 注意一点：计算时用的是物理像素，而不是px。 根据3.1的对应关系，可知iphone5的ppi为326对应的屏幕缩放比dpr为2 2.3通过window获取设备的dpr【update20161125】在移动端浏览器中及某些桌面浏览器中，window对象有一个devicePixelRatio属性，我们可以通过window.devicePixelRatio直接获取到设备的dpr。 3、dpx表示px和物理像素dp的关系 我们已经知道iphone5的dpr为2，给出一个像素在iphone5中的形象图如下： 这个图可以从2个角度理解 平面上：1px等于2的平方dp横向维度或者竖向维度上：1px等于2dp 3.1计算iphone5的逻辑像素由前置知识能得知iphone5的像素信息：四英寸1136 × 640 Retina Display 现在也已经知道iphone5的dpx为2，再根据上面的计算公式可以算出针对iphone5切图时其逻辑像素为：320px*568px。 4、由设备分辨率得到屏幕分辨率整个关系串联起来如下： 参考：http://www.imooc.com/u/2022616/courses?sort=publish 来自：http://www.cnblogs.com/starof/p/6098526.html]]></content>
      <tags>
        <tag>px</tag>
        <tag>webapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js如何获取服务器端时间？]]></title>
    <url>%2F2016%2F10%2F20%2FserverTime%2F</url>
    <content type="text"><![CDATA[用js做时间校正，获取本机时间，是存在bug的。 使用js也可获取到服务器时间，原理是使用 ajax请求，返回的头部信息就含有服务器端的时间信息，获取到就可以了。以下： 依赖jQuery代码： function getServerDate(){ return new Date($.ajax({async: false}).getResponseHeader(&quot;Date&quot;)); } 以上函数返回的就是一个Date对象，注意在使用ajax时必须同步，要不然无法返回时间日期。 无需填写请求链接； 如果服务器时间和本地时间有时差，需要做校正。 原生代码： 12345678910111213function getServerDate()&#123; var xhr = null; if(window.XMLHttpRequest)&#123; xhr = new window.XMLHttpRequest(); &#125;else&#123; // ie xhr = new ActiveObject(&quot;Microsoft&quot;) &#125; xhr.open(&quot;GET&quot;,&quot;/&quot;,false)//false不可变 xhr.send(null); var date = xhr.getResponseHeader(&quot;Date&quot;); return new Date(date);&#125; 同样返回的是一个Date对象，xhr.open()必须使用同步; 无需填写请求链接;open，send，和getResponseHeader 必须按序编写。 如需使用异步请求，可监听onreadystatechange状态来做不同的操作。 代码如下： 12345678910111213141516171819function getServerDate()&#123; var xhr = null; if(window.XMLHttpRequest)&#123; xhr = new window.XMLHttpRequest(); &#125;else&#123; // ie xhr = new ActiveObject(&quot;Microsoft&quot;) &#125; xhr.open(&quot;GET&quot;,&quot;/&quot;,true); xhr.send(null); xhr.onreadystatechange=function()&#123; var time,date; if(xhr.readyState == 2)&#123; time = xhr.getResponseHeader(&quot;Date&quot;); date = new Date(time); console.log(date); &#125; &#125;&#125; 使用异步不是很方便返回时间。 这里的readyState有四种状态，方便做不同处理： 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 失败状态，status的值： 200: “OK” 404: 未找到页面 作者：HelloBook 来自：http://www.cnblogs.com/hellobook/p/6112182.html]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再不用ES6就Out了--es6变量声明]]></title>
    <url>%2F2016%2F10%2F17%2FES6%2F</url>
    <content type="text"><![CDATA[ECMAScript 6 目前基本成为业界标准，它的普及速度比 ES5 要快很多，主要原因是现代浏览器对 ES6 的支持相当迅速，尤其是 Chrome 和 Firefox 浏览器，已经支持 ES6 中绝大多数的特性。 ES6的变量声明方式保留了var和function。新增加了let、const、class和import。 而且,let、const、class声明的全局变量再也不会和全局对象的属性挂钩了。 let12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061------------ let------------1、let只在所在的代码块中有效for (var i = 0; i &lt; 10; i++) &#123;&#125;console.log(i); //10for(let j = 0; j &lt; 10; j++) &#123;&#125;console.log(j);// Error: j is not define2、以前我们需要用IIFE解决的问题for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function () &#123; console.log(i); // 输出5次5 &#125;,0);&#125;for (var k = 0; k &lt; 5; k++) &#123; (function (k) &#123; setTimeout(function () &#123; console.log(k); //输出0,1,2,3,4 &#125;,0); &#125;)(k);&#125;for (let j = 0; j &lt; 5; j++) &#123; setTimeout(function () &#123; console.log(j); //输出0,1,2,3,4 &#125;,0);&#125;3、不存在变量声明提升console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2;可能动手实践的同学会发现在webpack配置的es6环境中。并不会出现这种情况，那主要是babel转码是还是讲let转成了var,不要纠结这个。4、暂时性死区TDZvar temp = 123;if (true) &#123; //TDZ start temp = &quot;abc&quot;; //ReferenceError console.log(temp); //ReferenceError //TDZ end let temp; console.log(temp); //undefined temp = 12; console.log(temp); //12&#125;其实这个也可以解释上面那条 不存在变量声明提升。同时在TDZ区域中使用typeof temp 也是不安全的。但是你typeof 未声明的变量 倒是返回undefined, 这就是TDZ的效果。同样这里你也可能试验不出来，你看一下bundle.js,你就懂了。5、let不允许重复声明&#123; let a = 1; let a = 10; //这里在转码的时候就报错了。&#125; const1234567891011121314151617---------- const----------1、大部分与let差不多。2、const （只读）（一旦声明必须赋值） const MAX = 123;MAX = 1; //转码阶段就爆错了。3、对于复合类型变量 (可以给他的属性赋值)const a = &#123;&#125;;a.name = &quot;dai&quot;;a.age = 21;4、如何你不想添加属性const b = Object.freeze(&#123;&#125;);b.name = &apos;dai&apos;; //TypeError 插曲–ES6引入了块级作用域123456789101112131415161718其实这也解释了为什么let、const在自己所在的代码块有效了。&#123; var b = 1; &#123; var b = 10; console.log(b); //10 &#125; console.log(b); //10&#125;&#123; let a = 1; &#123; let a = 2; console.log(a); //2 &#125; console.log(a); //1&#125; class1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980--------- class---------1、class作为es6的语法糖，实际上es5也可以实现的。class Point &#123; constructor (x, y) &#123; this.x = x; this.y = y; &#125; toString () &#123; return this.x + &apos;,&apos; + this.y; &#125;&#125;Object.assign(Point.prototype, &#123; getX () &#123; return this.x; &#125;, getY () &#123; return this.y; &#125;&#125;)let p1 = new Point(1,2);console.log(p1.toString()); //1,2console.log(p1.getX()); //1console.log(p1.getY()); //2console.log(Object.keys(Point.prototype)); // [&quot;getX&quot;, &quot;getY&quot;] (1)、方法之间不需要逗号分隔(2)、toString () &#123;&#125; 等价于 toString: function () &#123;&#125;(3)、你仍然可以使用Point.prototype(4)、你可以用Object.assign()一次性扩展很多方法(5)、类内部定义方法多是不可以枚举的(6)、constructor()&#123;&#125;是一个默认方法，如果没有添加，会自动添加一个空的。(7)、constructor默认返回实例对象（this），完全可以指定返回其他的对象。(8)、必须用new调用(9)、不存在变量提升(10)、当用一个变量去接受class时，可以省略classname(11)、es6不提供私有方法。2、使用extends继承class ThreeDPoint extends Point &#123; constructor (x, y, z) &#123; console.log(new.target); //ThreeDPoint super(x, y); this.z = z; &#125; toString () &#123; return super.toString() + &apos;,&apos; + this.z; &#125; static getInfo() &#123; console.log(&apos;static method&apos;); &#125; get z() &#123; return 4; &#125; set z(value) &#123; console.log(value); &#125;&#125;ThreeDPoint.getInfo(); // &quot;static method&quot;let ta = new ThreeDPoint(2,3,4);console.log(ta.toString()); //2,3,4console.log(ta.z); // 4ta.z = 200; // 200console.log(Object.getPrototypeOf(ThreeDPoint)); //Point(1)、constructor中必须调用super,因为子类中没有this,必须从父类中继承。(2)、子类的__proto__属性总是指向父类(3)、子类的prototype属性的__proto__总是指向父类的prototype(4)、Object.getPrototypeOf()获取父类(5)、super作为方法只能在constructor中(6)、super作为属性指向父类的prototype.(7)、在constructor中使用super.x = 2，实际上this.x = 2;但是读取super.x时，又变成了父类.prototype.x。(8)、原生构造函数是无法继承的。(9)、get set 方法可以对属性的赋值和读取进行拦截(10)、静态方法不能被实例继承。通过static声明(11)、静态属性只能 ThreeDPoint.name = &quot;123&quot; 声明 （与static没什么关系） import12345678910111213141516171819202122----------- import-----------1、ES6引入了自己的模块系统。通过export导出，import导入。2、与CommonJS不同的是，它是获取模块的引用，到用的时候才会真正的去取值。3、例如student.js中:let student = [ &#123; name: &apos;xiaoming&apos;, age: 21, &#125;, &#123; name: &apos;xiaohong&apos;, age: 18 &#125;]export default student; // 这种导出方式，你可以在import时指定它的名称。 4、在app.js中我们就可以这样用:import StudentList from &apos;./student.js&apos;; //指定名称console.log(StudentList[0].name); //xiaoming 作者：想做全栈的前端工程师 来自：http://www.jianshu.com/p/77265d84cc2b]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从HTTP到HTTPS-什么是HTTPS]]></title>
    <url>%2F2016%2F10%2F16%2Fhttp-https%2F</url>
    <content type="text"><![CDATA[HTTPS是互联网 web 大势所趋。各大网站都已陆续部署了HTTPS，这篇文章我们来探讨什么是HTTPS以及为什么要部署HTTPS。 这篇文章收录在《Said - 从HTTP到HTTPS》系列： 从 HTTP 到 HTTPS - 什么是 HTTPS 从 HTTP 到 HTTPS - IIS如何部署 HTTPS 从 HTTP 到 HTTPS - 网站部署 HTTPS 中需要做的事情 HTTP当你在浏览器输入一个网址 (例如 http://tasaid.com)的时候，浏览器发起一个 HTTP 请求，带着请求信息 (参见HTTP Headers)，连接到服务器，把请求信息递给服务器，服务器收到信息之后，解析相关的信息，然后进行处理，再返回浏览器请求的数据。 简单来说是这么一个流程： 小明 跟 浏览器爸爸 说我想要去中关村某个店家拿一些东西 (发起请求) 浏览器爸爸 就把 小明 要的东西记在一张清单上 (生成HTTP协议) 然后 浏览器爸爸 派出一个 线程小弟，噌噌噌跑到中关村的店里，把清单递给 店家，说小明要这些东西 (进行传输) 店家 让 线程小弟 稍等，然后去屋子里面拿小明的这些东西 (服务器收到请求) 店家 把东西拿出来后，并且也打印了一份清单，让 线程小弟 带着清单和东西一起拿回去 (服务器处理请求完毕) 然后 线程小弟 回到 浏览器爸爸 那边，把服务器给的清单和物品交给浏览器爸爸，浏览器爸爸根据清单核对物品 (浏览器处理响应) 然后把物品打包交给了 小明 (浏览器渲染并呈现界面) 看图说话： 这其中有个问题，浏览器爸爸和服务器都没有验证清单信息的有效性和对方的身份。万一有人在中间把线程小哥拦下来，暴揍一顿，然后把物品清单给换了怎么办？或者有人把线程小哥在半路上暴揍一顿，拿了清单换了另外一个小哥怎么办？ 这是个很严肃的问题：假如服务器要把一些东西锁在柜子里，需要小明给密码才可以打开柜子。然后小明把密码写在清单上让浏览器爸爸交给服务器。这时候，如果这张清单被人拦截下来，不就得到了小明的密码？ 简单来说，传输的信息中包含用户密码，被拦截了怎么办？ HTTPS正因为HTTP请求有这些安全性的问题，所以HTTPS诞生了，致力于解决了这些安全性问题，我们进行一下对比： 安全性 HTTP HTTPS 窃听风险 传递的信息是明文的，可能会被有心人拦截下来窃听 信息加密传播 篡改风险 传递的信息可能会被篡改 信息校验，一旦被篡改立刻就会被发现 伪装风险 没有验证通信另外一头对方的身份，可能遭遇伪装 身份校验 那么HTTPS是如何做到更安全的呢？ 简单来说，HTTPS 即是在 HTTP 下加入了一层 SSL 加密，所以被称为HTTPS。具体的加密过程则是公匙加密法： 客户端向服务器索要公匙，然后使用公匙加密信息 服务器收到加密后的信息，用自己的私匙解密 公匙密码和算法都是公开的，而私匙则是保密的。加密使用的公匙和解码使用的密匙都是不相同的，因此这是一个 非对称加密 算法。 数字证书提及 HTTPS ，就会听到大家说需要证书才能部署，那么什么是证书呢？ 因为互联网不安全，公匙也是信息的一部分，也是会有被篡改的风险的。所以引入了互联网权威机构 - CA 机构，又称为证书授权 (Certificate Authority) 机构，浏览器会内置这些”受信任的根证书颁发机构” (即 CA)。 服务端向权威的身份鉴定 CA 机构申请数字证书，CA 机构验证了网站之后，会把网站录入到内部列表，采用 Hash 把服务端的一些相关信息生成摘要，然后 CA 机构用自己的私匙，把服务端的公匙和相关信息一起加密，然后给申请证书的服务端颁发数字证书，用于其他客户端 (比如浏览器) 认证这个网站的公匙。 客户端通过服务端下发的证书，找到对应的 CA，然后向 CA 验证这个证书是否有效，CA 验证通过之后，下发服务端的公匙。 因为 CA 是权威并且可信的，所以客户端 (浏览器) 信任 CA，而 CA 又信任经过认证的服务端 ，所以客户端 (浏览器) 也信任这个服务端，这就是信任链 (Chain Of Trust)。 而 CA 颁发的数字证书，一般包含这些信息： 简单来说：为了保证公匙是安全的，所以通过数字证书验证公匙。 加密通信一条完整的HTTPS请求应该是这样的： 客户端 (浏览器) 发起 HTTP 请求，请求连接服务端，发送支持的加密通信协议 (和版本)，并且生成一个随机数，后续用于生成”对话密钥”。 服务端确认加密通信协议 (和版本)，同时也生成一个随机数，后续用于生成”对话密匙”，并且将 CA 颁发的数字证书，一起发送给客户端。 客户端收到数字证书后，检测内置的”受信任的根证书颁发机构”，查看解开数字证书的公匙是否在。 如果解开数字证书的公匙存在，则使用它解开数字证书，得到正确的服务器公匙，同时再次生成一个随机数，用于服务器公匙加密，并发送给服务器。 此时本地和服务器同时将三个随机数，根据约定的加密方法进行加密，各自生成本次会话的所使用的同一把 “会话密匙” 。6.到这里，认证阶段已经完毕，数据传输从 非对称加密 换成了 对称加密 (因为考虑到性能)，接下来所有的数据传输都是使用HTTP协议进行传输，只不过使用了 “会话密匙” 来加密内容。 见下图： 来自：http://www.cnblogs.com/silin6/p/5928503.html]]></content>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动Web利器transformjs入门]]></title>
    <url>%2F2016%2F10%2F16%2Ftransformjs%2F</url>
    <content type="text"><![CDATA[简介在过去的两年，越来越多的同事、朋友和其他不认识的童鞋进行移动web开发的时候，都使用了transformjs，所有必要介绍一下，让更多的人受益，提高编程效率，并享受编程乐趣。（当然transformjs不仅仅支持移动设备，支持CSS3 3D Transforms的浏览器都能正常使用transformjs） 传送门官方网站：http://alloyteam.github.io/AlloyTouch/transformjs/ Github地址：https://github.com/AlloyTeam/AlloyTouch/tree/master/transformjs 安装npm install css3transform APITransform(domElement, [notPerspective]);通过上面一行代码的调用，就可以设置或者读取 domElement的”translateX”, “translateY”, “translateZ”, “scaleX”, “scaleY”, “scaleZ”, “rotateX”, “rotateY”, “rotateZ”, “skewX”, “skewY”, “originX”, “originY”, “originZ”！ 方便吧！ 使用姿势123456789Transform(domElement);//or Transform(domElement, true);//set &quot;translateX&quot;, &quot;translateY&quot;, &quot;translateZ&quot;, &quot;scaleX&quot;, &quot;scaleY&quot;, &quot;scaleZ&quot;, &quot;rotateX&quot;, &quot;rotateY&quot;, &quot;rotateZ&quot;, &quot;skewX&quot;, &quot;skewY&quot;, &quot;originX&quot;, &quot;originY&quot;, &quot;originZ&quot;domElement.translateX = 100;domElement.scaleX = 0.5;domElement.originX = 50;//get &quot;translateX&quot;, &quot;translateY&quot;, &quot;translateZ&quot;, &quot;scaleX&quot;, &quot;scaleY&quot;, &quot;scaleZ&quot;, &quot;rotateX&quot;, &quot;rotateY&quot;, &quot;rotateZ&quot;, &quot;skewX&quot;, &quot;skewY&quot;, &quot;originX&quot;, &quot;originY&quot;, &quot;originZ&quot;console.log(domElement.translateX ) 传统的CSS3编程的问题以前，我们一般使用animate.css、zepto/jQuery的animate方法或者tween.js+css3进行交互特效编程。总结下来有三个缺点： 不直观 不直接 不方便 不直观看下面这张图： 顺序影响结果，不直观。那么为什么会是这个结果？可以通过new WebKitCSSMatrix(transform_str)对比最终的matrix。 这也直接说明了矩阵不符合交换律。AB!=BA 不直接zepto姿势： 12345$(&quot;#some_element&quot;).animate(&#123; opacity: 0.25, left: &apos;50px&apos;, color: &apos;#abcdef&apos;, rotateZ: &apos;45deg&apos;, translate3d: &apos;0,10px,0&apos;&#125;, 500, &apos;ease-out&apos;) translate3d: ‘0,10px,0’非常不方便，无法step递进递减控制。更别提配合一些运动或者时间的库来编程了。可能你会反驳’ease-out’不就可以实现缓动吗？但是如果我需要让x和y以及z分别对应不同的缓动函数，这种基于字符串编程的形式就费劲了~~ 这里还需要注意的是，zepto里的顺序也会影响结果。因为其最后也是拼成string赋给dom元素。 tween.js姿势 1234567891011var position = &#123; x: 100, y: 100, rotation: 0 &#125;, target = document.getElementById(&apos;target&apos;); new TWEEN.Tween(position) .to(&#123; x: 700, y: 200, rotation: 359 &#125;, 2000) .delay(1000) .easing(TWEEN.Easing.Elastic.InOut) .onUpdate(function update() &#123; var t_str= &apos;translateX(&apos; + position.x + &apos;px) translateY(&apos; + position.y + &apos;px) rotate(&apos; + Math.floor(position.rotation) + &apos;deg)&apos;; element.style.transform = element.style.msTransform = element.style.OTransform = element.style.MozTransform = element.style.webkitTransform = t_str; &#125;); 使用字符串的方式，看着就心累。更别提写的过程要遭受多少折磨。 animate.css姿势: 12345678910111213141516@keyframes pulse &#123; from &#123; -webkit-transform: scale3d(1, 1, 1); transform: scale3d(1, 1, 1); &#125; 50% &#123; -webkit-transform: scale3d(1.05, 1.05, 1.05); transform: scale3d(1.05, 1.05, 1.05); &#125; to &#123; -webkit-transform: scale3d(1, 1, 1); transform: scale3d(1, 1, 1); &#125;&#125; animate.css封装了一大堆关键帧动画，开发者只需要关心添加或者移除相关的动画的class便可以。这一定程度上给交互特效带来了极大的遍历，但是要有硬伤： 可编程性不够高 适用于简单场景 没有change回调，只有end回调 不方便transform的旋转点基准点默认是在中心，但是有些是时候，不系统在中心，我们传统的做法是使用transform-origin来设置基准点。 注意，是另一个属性transform-origin，而不是transform。但是如果需要运动transform-origin呢？这种设计是不是就废了？有没有需要运动origin的场景？这个在游戏设计中是经常会使用的到，这个以后另外单独开篇再说，事实就是，有场景是需要运动origin来达到某种效果。 transformjs基于上面种种不便，所以有了transformjs！ transformjs作为腾讯AlloyTeam移动开发利器之一，广泛应用于手Q Web、微信Web相关业务开发 transformjs专注于CSS3 transform读取和设置的一个超轻量级js库，大大提高了CSS3 transform的可编程性 transformjs高度抽象，不与任何时间、运动框架捆绑，所以可以和任意时间、和运动框架轻松搭配使用 transformjs使用matrix3d为最终输出给dom对象，硬件加速的同时，不失去可编程性 transformjs拥有超级易用的API，一分钟轻松上手，二分钟嵌入真实项目实战 transformjs扩展了transform本身的能力，让transform origin更加方便 作者：【当耐特】 来自：http://www.cnblogs.com/iamzhanglei/p/6100817.html]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片的赖加载(lazyLoad)]]></title>
    <url>%2F2016%2F10%2F16%2Flazyload%2F</url>
    <content type="text"><![CDATA[懒加载的意义（在线demo预览）尽管很多公司的网页都有一些限制，比如页面的最大的图片大小不得大于50k,也有很多图片优化工具fis3、gulp等等，但是如果图片太多还是会影响页面的加载速度，快则几十秒慢则几十分钟，这样会导致用户流失。 图片的加载对页面的加载速度有很大影响！！所以，对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验，即图片赖加载~ 原理将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。 当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图片赖加载&lt;/title&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0&quot;&gt; &lt;!-- 启用webAPP全屏模式--&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; &lt;!-- 隐藏状态栏或者设置状态栏的颜色--&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt; &lt;!-- 忽略数字自动识别为电话号码--&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; &lt;!--控制缓存的失效日期 --&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;-1&quot;&gt; &lt;!-- 禁止转码--&gt; &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot;&gt; &lt;!-- 禁止缓存访问页面--&gt; &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta name=&quot;applicable-device&quot; content=&quot;mobile&quot;&gt; &lt;!-- 页面关键词--&gt; &lt;meta content=&quot;&quot; name=&quot;keywords&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/img_lazy.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;images/1.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;images/2.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;images/3.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;images/4.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;images/5.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;images/6.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;images/7.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;&quot; data-src=&quot;images/8.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;!--图片赖加载的JS--&gt; &lt;script src=&quot;js/imgLazyLoad.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718*&#123; margin: 0; padding: 0; box-sizing: border-box; list-style: none; border: 0; outline: 0;&#125;.main&#123; max-width: 640px; width: 100%; margin: 0 auto;&#125;img&#123; display: block; width: 100%; height: 640px;&#125; 12345678910111213141516171819202122/** * Created by Administrator on 2016/11/28. */!function()&#123; var imgs = document.getElementsByTagName(&quot;img&quot;); var num = imgs.length; var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 lazyload(); //页面载入完毕加载可是区域内的图片 window.onscroll = lazyload; function lazyload() &#123; //监听页面滚动事件 var seeHeight = document.documentElement.clientHeight; //可见区域高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (var i = n; i &lt; num; i++) &#123; if (imgs[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (imgs[i].getAttribute(&quot;src&quot;) == &quot;&quot;) &#123; imgs[i].src = imgs[i].getAttribute(&quot;data-src&quot;); &#125; n = i + 1; &#125; &#125; &#125;&#125;(); 将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。 当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。 作者：九成 来自：http://www.cnblogs.com/-walker/p/6108866.html]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>lazyLoad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5知识]]></title>
    <url>%2F2016%2F10%2F15%2Fhtml-knowledge%2F</url>
    <content type="text"><![CDATA[Doctype作用？标准模式与兼容模式各有什么区别? （1）、&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于&lt;html&gt;标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 （2）、标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 HTML5 为什么只需要写&lt;!DOCTYPE HTML&gt;？ HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 行内元素有哪些？块级元素有哪些？空(void)元素有那些？ 首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。 （1）行内元素有：a b span img input select strong（强调的语气） （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p （3）常见的空元素： &lt;br&gt;&lt;hr&gt;&lt;img&gt;&lt;input&gt;&lt;link&gt;&lt;meta&gt; 鲜为人知的是： &lt;area&gt;&lt;base&gt;&lt;col&gt;&lt;command&gt;&lt;embed&gt;&lt;keygen&gt;&lt;param&gt;&lt;source&gt;&lt;track&gt;&lt;wbr&gt; 页面导入样式时，使用link和@import有什么区别？ （1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; （3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 常见的浏览器内核有哪些？ Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 绘画 canvas; 用于媒介回放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件，calendar、date、time、email、url、search; 新的技术webworker, websocket, Geolocation; 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes； 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式。 当然也可以直接使用成熟的框架、比如html5shim; &lt;!–[if lt IE 9]&gt; &lt;script&gt; src=”http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]–&gt; 如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素 简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 HTML5的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 如何使用： 1、页面头部像下面一样加入一个manifest的属性； 2、在cache.manifest文件的编写离线存储的资源； CACHE MANIFEST v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 3、在离线状态时，操作window.applicationCache进行需求实现。 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？ 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 iframe有那些缺点？ *iframe会阻塞主页面的Onload事件； *搜索引擎的检索程序无法解读这种页面，不利于SEO; *iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题。 Label的作用是什么？是怎么用的？ label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 &lt;label for=”Name”&gt;Number:&lt;/label&gt; &lt;input type=“text“name=”Name” id=”Name”/&gt; &lt;label&gt;Date:&lt;input type=”text” name=”B”/&gt;&lt;/label&gt; HTML5的form如何关闭自动完成功能？ 给不想要提示的 form 或某个 input 设置为 autocomplete=off。 如何实现浏览器内多个标签页之间的通信? (阿里) WebSocket、SharedWorker； 也可以调用localstorge、cookies等本地存储方式； localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件， 我们通过监听事件，控制它的值来进行页面信息通信； 注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常； webSocket如何兼容低浏览器？(阿里) Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面可见性（Page 1. Doctype作用？标准模式与兼容模式各有什么区别? （1）、&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于&lt;html&gt;标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 （2）、标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 HTML5 为什么只需要写&lt;!DOCTYPE HTML&gt;？ HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 行内元素有哪些？块级元素有哪些？空(void)元素有那些？ 首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。 （1）行内元素有：a b span img input select strong（强调的语气） （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p （3）常见的空元素： &lt;br&gt;&lt;hr&gt;&lt;img&gt;&lt;input&gt;&lt;link&gt;&lt;meta&gt; 鲜为人知的是： &lt;area&gt;&lt;base&gt;&lt;col&gt;&lt;command&gt;&lt;embed&gt;&lt;keygen&gt;&lt;param&gt;&lt;source&gt;&lt;track&gt;&lt;wbr&gt; 页面导入样式时，使用link和@import有什么区别？ （1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; （3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 常见的浏览器内核有哪些？ Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 绘画 canvas; 用于媒介回放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件，calendar、date、time、email、url、search; 新的技术webworker, websocket, Geolocation; 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes； 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式。 当然也可以直接使用成熟的框架、比如html5shim; &lt;!–[if lt IE 9]&gt; &lt;script&gt; src=”http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]–&gt; 如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素 简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 HTML5的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 如何使用： 1、页面头部像下面一样加入一个manifest的属性； 2、在cache.manifest文件的编写离线存储的资源； CACHE MANIFEST v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 3、在离线状态时，操作window.applicationCache进行需求实现。 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？ 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 iframe有那些缺点？ *iframe会阻塞主页面的Onload事件； *搜索引擎的检索程序无法解读这种页面，不利于SEO; *iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题。 Label的作用是什么？是怎么用的？ label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 &lt;label for=”Name”&gt;Number:&lt;/label&gt; &lt;input type=“text“name=”Name” id=”Name”/&gt; &lt;label&gt;Date:&lt;input type=”text” name=”B”/&gt;&lt;/label&gt; HTML5的form如何关闭自动完成功能？ 给不想要提示的 form 或某个 input 设置为 autocomplete=off。 如何实现浏览器内多个标签页之间的通信? (阿里) WebSocket、SharedWorker； 也可以调用localstorge、cookies等本地存储方式； localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件， 我们通过监听事件，控制它的值来进行页面信息通信； 注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常； webSocket如何兼容低浏览器？(阿里) Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面可见性（Page Visibility API）可以有哪些用途？ 通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等; 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放； 如何在页面上实现一个圆形的可点击区域？ 1、map+area或者svg 2、border-radius 3、纯js实现需要求一个点在不在圆上简单算法、获取鼠标坐标等等 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。 &lt;div style=”height:1px;overflow:hidden;background:red”&gt;&lt;/div&gt; 网页验证码是干嘛的，是为了解决什么安全问题。 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水； 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 title与h1的区别、b与strong的区别、i与em的区别？ title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响； strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而&lt;B&gt;是展示强调内容。 i内容展示为斜体，em表示强调的文本； Physical Style Elements – 自然样式标签 b, i, u, s, pre Semantic Style Elements – 语义样式标签 strong, em, ins, del, code 应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。Visibility API）可以有哪些用途？ 通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等; 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放； 如何在页面上实现一个圆形的可点击区域？ 1、map+area或者svg 2、border-radius 3、纯js实现需要求一个点在不在圆上简单算法、获取鼠标坐标等等 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。 &lt;div style=”height:1px;overflow:hidden;background:red”&gt;&lt;/div&gt; 网页验证码是干嘛的，是为了解决什么安全问题。 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水； 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 title与h1的区别、b与strong的区别、i与em的区别？ title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响； strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而&lt;B&gt;是展示强调内容。 i内容展示为斜体，em表示强调的文本； Physical Style Elements – 自然样式标签 b, i, u, s, pre Semantic Style Elements – 语义样式标签 strong, em, ins, del, code 应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。 作者：天殇海韵 来自：http://www.cnblogs.com/tianshang/p/6057826.html]]></content>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Offensive-and-defensive]]></title>
    <url>%2F2016%2F10%2F15%2FOffensive-and-defensive%2F</url>
    <content type="text"><![CDATA[随着各浏览器安全功能的提高，前端防御面临的问题也没有之前那么复杂，但浏览器的防御措施并不能百分百的保证网站的安全。浏览器的XSS Auditor，使得反射型xss几乎被废；CSP(Content-Security-Policy)、X-XSS-Protection可以禁止不可信源的脚本执行！无疑，这对xss攻击是一记重拳。但是道高一尺，魔高一丈，尤其是在安全界，永远应该记住的一句箴言就是“只有相对的安全，没有绝对的安全”。本文重点介绍现代浏览器的安全特性以及浏览器依然不能防御的攻击手段。 XSSXSS攻击：跨站脚本攻击(Cross Site Scripting)，为不和 CSS混淆，故将跨站脚本攻击缩写为XSS。 为什么叫跨站脚本？简单来说，就是在一个网站上运行了该网站之外的js脚本(当然，开发者自已引用的可信源的js不算，比如使用了cdn的 jQuery )。 一个经典的例子假设有一个搜索页面，关键字以Get方法传递。假设，搜索页面在输出结果时会无过滤的将用户的关键字回显到网页上，大致逻辑如下： 123456789//xss.php&lt;?php if(isset($_REQUEST[&quot;wd&quot;])) $wd=$_REQUEST[&quot;wd&quot;]; if($wd)&#123; echo &quot;&lt;div&gt;关键字&apos;$wd&apos;搜索的结果如下：&lt;/div&gt;&quot;&#125; ...?&gt; 然后搜索请求的链接是: http://localhost/test/haker/xss.php?wd=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 或者为了隐蔽编一下码： http://localhost/test/haker/xss.php?wd=ddd%3Cscript%3Ealert(%22%22)%3C/script%3E 在es6下，你甚者可以用unicode码点。 如果是在几年前，你的浏览器大致都会弹出这样一个窗口： 然而，现在不行了，在chrome和safari下，如果发现响应中包含请求参数中相同的代码字符串，它们就会拒绝执行这些代码，你会收到如下的错误提示： The XSS Auditor refused to execute a script in &apos;http://localhost/test/haker/xss.php?wd=ddd%3Cscript%3Ealert(%22xss%22)%3C/script%3E&apos; because its source code was found within the request. The auditor was enabled as the server sent neither an &apos;X-XSS-Protection&apos; nor &apos;Content-Security-Policy&apos; header. XSS Auditorxss auditor是Chrome 和 Safari中内建的一个防御xss攻击的功能模块，相当于一个审计器，有预设规则，主要功能就是针对上述这种情况。此功能默认是开启的，当然也可以关闭，需要在response header中显式指定： //关闭 xss auditor X-XSS-Protection: 0 当然，更强大的是，触发后还可以将详情上报，便于分析跟踪： X-XSS-Protection: 1; report=http://example.com/your_report_URI 也可以使用block模式：一旦触发，当前页面就会终止，并同时展示一个空白页面给用户： X-XSS-Protection: 1; mode=block 如果将请求换成post，xss auditor还会被触发吗？答案是：可以！ XSS Auditor的缺点我们将后台逻辑改一下，给每个”&gt;”后加一个分号。 1234567&lt;?php if(isset($_REQUEST[&quot;wd&quot;])) $wd=str_replace(&quot;&gt;&quot;,&quot;&gt;;&quot;,$_REQUEST[&quot;wd&quot;]); if($wd)&#123; echo &quot;&lt;div&gt;关键字&apos;$wd&apos;搜索的结果如下：&lt;/div&gt;&quot;&#125; ?&gt; 然后依然是之前的链接，刷新： 成功了，当然本例只是一个说明，通常情况下，我们都会对用户提交的数据进行一些处理，如果这些处理导致和提交的内容不一样了，但是仍然可以执行，比如像本例一样。那么xss auditor 就无能为力了。不过xss auditor本身的智能度也挺高，像字符编码，大小写变化这种变化依然躲不过xss auditor。 存储型xss比如网站有个留言板功能，但后台未对用户输入进行过滤，攻击者可以在留言编辑框中输入： &lt;script src=&quot;http://www.hacker.org/xss.payload.js&quot;&gt;&lt;/script&gt; 然后再随便输入点其它文字，提交留言，提交成功后，内容将会被保存到服务器数据库，只要再访问留言列表，这个就会被插入到网页中，xss.payload.js中的代码就可以执行，如果访问的用户都是已登录用户，xss.payload.js可以获取老浏览用户的信息，如的登录token、用户的个人资料等，payload甚至可以拉一个全家桶下来。以前的防御手段主要是对用户输入进行过滤如：去除html标签，实体化，关键字过滤等等，这样一来，最终的结果就是后台的大多数代码都是在做字符串验证，非常的让人不舒服。所以W3 org引入了CSP: Content-Security-PolicyContent-Security-Policy 是W3 org草案，主要是用来定义页面可以加载哪些资源，减少 XSS 的发生，chrome已经支持，详情可以参考Chrome CSP 官方文档。这样一来，从源头上杜绝了不可信源的xss payload加载的可能型。比如下面的配置只允许加载本域下的脚本： Content-Security-Policy: default-src &apos;self&apos; 这样即使页面被注入了外部脚本，浏览器也会拒绝执行，你会收到如下的错误提示： Refused to load the script &apos;http://www.hacker.org/xss.payload.js&apos; because it violates the following Content Security Policy directive: &quot;default-src &apos;self&apos;&quot;. Note that &apos;script-src&apos; was not explicitly set, so &apos;default-src&apos; is used as a fallback. 当然，CSP能指定的规则是很多的，甚至也可以禁止内联脚本执行，详情请移步W3 CSP。 浏览器的支持情况请移步Can I use Content Security Policy。 CSRF复制一段百度的介绍：CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS）,但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 CSRF攻击流程 用户登录受信任网站A。 在不退出 A的情况下，访问危险网站B（攻击者网站或攻击者挂马的网站）。 举个例子，假设A网站是个博客网站，用户登录之后可以删除自己的博客，删除的链接如下： http://www.a.com/resource/delete/{blogid} 先看看后台登录逻辑：用户登录成功后，创建session，然后将session id通过cookie传给浏览器，这样便可以跟踪用户登录状态，以后所有的操作都是登录态的操作。删除博客时后台的逻辑是这样的：删除之前，先检验用户身份，如果身份校验通过则删除，如果未登录，则重定向到登录页面。 假设攻击者在这篇博客下面评论如下： “hi 你好，读了你的博客很受益，我有一个问题，请大牛解惑，链接是b，多谢️！” 看了这条评论后，你内心很满足，于是决定指导一下这位粉丝，你点了链接，回答了问题，自信满满地返回到自己的博客，然后突然发现 “博客找不到了”！ 怪哉，why？ 中招了！ 问题就在你刚才访问过的网页。假设你的博客id=8, b网页内容大致如下： 123456&lt;html&gt; ... &lt;img src=&apos;http://www.a.com/resource/delete/8&apos;/&gt; ...&lt;html&gt; 网页中img src正是删除你的博客链接，或许你会说，后台不是有身份认证么？是的，后台的确有身份认证，但此时访问b，你并没有退出登录，而此时b中浏览器又发起了http://www.a.com/resource/delete/8请求（同时会发送该域下的cookie），这样一来，后台用户认证会通过，所以删除会成功。ps:是不是以后可以用这招去删帖了。。。 如果是post请求呢？ 12345678910&lt;html&gt; ... &lt;form method=&quot;post&quot; action=&quot;http://www.a.com/resource/delete/&quot;&gt; &lt;input type=&quot;hidden&quot; name=id value=8&gt; &lt;/form&gt; &lt;script&gt; $(&quot;form&quot;).submit() &lt;/script&gt; ...&lt;html&gt; 在b页面中，制造一个表单，然后直接触发提交，依然可以！ CSRF攻击防御随机值法 后台对每一次请求都生成一个随机值，保存在session中，然后再将该值发送给页面，可以在cookie中，也可以在一个隐藏的表单中（大多数后台框架都是这么做的，如php的symfony、laraval）,甚至也可以是在验证码中。下面以表单为例来说明： 12345678&lt;?php $hash = random(100000);?&gt;&lt;form method=&quot;post&quot; action=&quot;delete/&quot;&gt;&lt;input type=&quot;id&quot; name=&quot;8&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;hash&quot; value=&quot;&lt;?php $hash; ?&gt;&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt; 然后提交时，服务端再对比hash值是不是和session中一样。 攻击者网站时无法预估这个hash的。但是请注意，在上面所述的攻击场景中，把hash存在cookie中时不行的。 检测refer后台在进行删除操作之前先判断refer，如果不是本域的请求，则直接拒绝，这种做法很有效。但是，想想这样一个场景：如果博客允许评论里面插图，攻击者完全可以将 img插入到原网站中，这样refer还是在当下域名，博客依然会被删除。所有可能引入链接的html标签都是不可信的，如script、link，后台过滤策略一定要考虑到。 总结其实可以看到，上面的攻击虽说现场是在前端，但是本质还是服务端验证不足、过滤不全导致。对于前端来说，防御所做的事有限，但是站在攻击者角度来讲，又必需精通前端。今天只是web渗透的皮毛，如果大家有兴趣，可以在评论中留言，以后也可以多分享一些服务器渗透、操作系统安全方面的，当然根据期待度以及我的时间而定。 作者：杜文 来自：http://www.jianshu.com/p/15fece7e1a3e]]></content>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native安装]]></title>
    <url>%2F2016%2F10%2F15%2Freact-native%2F</url>
    <content type="text"><![CDATA[安装Homebrew Homebrew, Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件。 /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 译注：在Max OS X 10.11（El Capitan)版本中，homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复： sudo chown -R `whoami` /usr/local Node使用Homebrew来安装Node.js. React Native需要NodeJS 4.0或更高版本。本文发布时Homebrew默认安装的是6.x版本，完全满足要求。 npm install node React Native的命令行工具（react-native-cli）React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。 npm install -g react-native-cli 如果你看到EACCES: permission denied这样的权限报错，那么请参照上文的homebrew译注，修复/usr/local目录的所有权： sudo chown -R `whoami` /usr/local 推荐安装的工具WatchmanWatchman是由Facebook提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager可以快速捕捉文件的变化从而实现实时刷新）。 npm install watchman FlowFlow是一个静态的JS类型检查工具。译注：你在很多示例中看到的奇奇怪怪的冒号问号，以及方法参数中像类型一样的写法，都是属于这个flow工具的语法。这一语法并不属于ES标准，只是Facebook自家的代码规范。所以新手可以直接跳过（即不需要安装这一工具，也不建议去费力学习flow相关语法）。 npm install flow 测试安装react-native init AwesomeProject cd AwesomeProject react-native run-ios 然后你看到这个见面就证明你安装完成了，可以开始开发手机App了。 转载标明出处或联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selector]]></title>
    <url>%2F2016%2F10%2F15%2Fselector%2F</url>
    <content type="text"><![CDATA[CSS选择器：基础、关系、属性、伪类、伪对象等；选择器优先级的计算： style=1000(内联样式表) ID=100 class=10 element=1 1.基础选择器 ID&gt;class&gt;element&gt;*2.关系选择器 包含（后代）选择器 E F E为F的外层元素 子选择器 E&gt;F E为F的父级 相邻选择器 E+F 选择与自身相邻，且紧跟在自身后面的兄弟元素 兄弟选择器 E~F 所有的符合条件的位于自身后面的兄弟元素 并集选择器 E，F 两者不需要有什么关系，只是同用一个样式 交集选择器 E.F ,E#F 具有F类名或id名的E元素 3.属性选择器 E与[ ]中不要有空格通过属性来选择，定义的时候用[] 来定义: 【注意事项：1.必须是属性； 2. 属性选择器耗费资源比基本选择器大；】 E[att] 通过属性名来选择 E[att=”val”] 属性名和属性值都符合才会被选中； E[att~=”val”] 其中一个class符合即被选中； E[att^=”val”] 以val开头的att属性被选中； E[att$=”val”] 以val结尾的att属性被选中； E[att*=”val”] 包含了val内容的属性值的元素会被选中； E[att|=”val”] 以val开头，并且后面紧跟中划线的元素被选中； [class]{ color：red ; } —–&gt;所有具有类名的元素都为红色； 4. 伪类 E与：中不要有空格通过冒号：定义伪类 ：root 选择匹配文档的根元素（每个文档只有一个根元素） E:link 超链接未被点击时的状态（颜色、背景） E:visited 超链接被访问后的状态 E:hover 鼠标悬停时的状态，不限a标签，其它元素也可以 E:active 鼠标按下时的状态 【测试超链接的几个状态时，可以用快捷键Ctrl+H：清除缓存】 E:not(s) 除去括号里面的选择器的元素，其它的元素会被选中。括号里面可以是class选择器也可以是id选择器，要通过.或#来选择，并且不要加引号 E:first-child E需要具有父级，并且E是父级的第一个元素 E代表了要操作元素本身，并非父元素 E:last-child 同上 E:only-child 具有父元素，并且E是父元素中唯一的 E:empty 匹配完全没有内容的E元素，空格和换行都算做内容。 E:checked 可以匹配被选中的元素， 如radio 和select 中的option &lt;input type=”radio” name=”gender” checked=”checked” /&gt; &lt;option value=”0” selected=”selected” &gt;汽车&lt;/option&gt; ——-cheked实例 html结构 &lt;form action=””&gt; &lt;input type=”radio” name=”gender” /&gt;&lt;span&gt;男&lt;/span&gt; &lt;input type=”radio” name=”gender”/&gt;&lt;span&gt;女&lt;/span&gt; &lt;select name=”” id=””&gt; &lt;option value=”0”&gt;汽车&lt;/option&gt; &lt;option value=”1” selected=”selected”&gt;火车&lt;/option&gt; &lt;option value=”2”&gt;自行车&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; css样式 input:checked + span{color: red;} option:checked{ color: aqua;} 5.伪对象选择器（不存在于HTML中，不会改变文档的结构） E与::中不要有空格用::来定义伪元素（伪对象） E::before{ content:” “; } E::after{ content:” “; } 例： 16° —–&gt; ::after 结合position:absolute; 利用伪元素给文档添加图片 （display：block；设置大小；） 利用伪元素清除浮动：.clearfloat:after {content: “”; display: block; height:0; clear:both; visibility: hidden;} 利用伪元素绘制简单的图形，例如小三角等; 伪元素的用处还有很多，不再一一列举； 【注意事项： E 只能有一个after和一个before，若有多个按最后一个显示； 伪元素不存在于文档流，不能被选中;】 作者：AinyTong 来自：http://www.cnblogs.com/AinyTong/p/6099608.html]]></content>
      <tags>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学PHP之错误处理]]></title>
    <url>%2F2016%2F10%2F15%2FphpErr%2F</url>
    <content type="text"><![CDATA[前面的话 错误处理对于程序开发至关重要，不能提前预测到可能发生的错误，不能提前采取恢复策略，可能导致较差的用户体验。本文将详细介绍PHP的错误处理 [注意]关于javascript的错误处理机制移步至此 错误报告PHP程序的错误发生一般归属于下列三个领域： 语法错误 语法错误最常见，并且也容易修复。如：代码中遗漏一个分号。这类错误会阻止脚本的执行 运行时错误 这种错误一般不会阻止PHP脚本的执行，但会阻止当前要做的事情。输出一条错误，但php脚本继续执行 逻辑错误 这种错误最麻烦，既不阻止脚本执行，也不输出错误消息 [注意]若将php.ini配置文件中的display_errors从默认的on设置为off，将不显示任何错误 在PHP脚本中可调用ini_set()函数，动态设置php.ini配置文件 ini_set(&quot;display_errors&quot;,&quot;On&quot;); //显示所有错误信息 错误级别 实际上，表格中的13个错误类型可以分为3类：注意级别、警告级别和错误级别。一般地，在开发过程中，忽略注意级别的错误 12345678910&lt;?php getType($a);//未定义变量，注意级别 echo &quot;1111111111111111&lt;br&gt;&quot;; getType();//未传入参数，警告级别 echo &quot;222222222222222222222&lt;br&gt;&quot;; getType3();//函数名错误，错误级别 echo &quot;333333333333333333333&lt;br&gt;&quot;;?&gt; 错误处理1、第一种错误处理方法是修改配置文件 错误级别默认为提示所有级别的错误：error_reporting = E_ALL 把error_reporting = E_ALL改为error_reporting = E_ALL &amp; ~E_NOTICE 表示不提示注意级别的错误。然后，重启服务生效 error_reporting = E_ALL &amp; ~E_NOTICE 抛出任何非注意的错误，默认值 error_reporting = E_ERROR | E_PARSE | E_CORE_ERROR 只考虑致命的运行时错误、新解析错误和核心错误 error_reporting = E_ALL &amp; ~(E_USER_ERROR | E_USER_WARNING | E_USER_NOTICE) 报告除用户导致的错误之外的所有错误 2、第二种错误处理方法是使用错误处理函数在PHP脚本可以通过error_reporting( )函数动态设置错误报告级别 1234567891011&lt;?php error_reporting(E_ALL &amp; ~E_NOTICE); getType($a);//注意级别 echo &quot;1111111111111111&lt;br&gt;&quot;; getType();//警告级别 echo &quot;222222222222222222222&lt;br&gt;&quot;; getType3();//错误级别 echo &quot;333333333333333333333&lt;br&gt;&quot;;?&gt; 自定义错误处理自定义错误报告的处理方式，可以完全绕过标准的PHP错误处理函数，这样就可以按自己定义的格式打印错误报告，或改变错误报告打印的位置，以下几种情况可以考虑自定义错误处理：1、记下错误的信息，及时发现一些生产环境出现的问题；2、屏蔽错误；3、控制错误的输出; 4、作为调试工具 使用set_error_handler()函数来设置用户自定义错误处理 1234567891011121314151617&lt;?php //error_reporting(E_ALL &amp; ~E_NOTICE); //在php中注册一个函数来处理错误报告，替代默认的方式 set_error_handler(&quot;myerrorfun&quot;); $mess = &quot;&quot;; //自定义错误报告处理函数 function myerrorfun($error_type, $error_message, $error_file, $error_line) &#123; global $mess; $mess.=&quot;发生错误级别为&#123;$error_type&#125;类型, 错误消息&lt;b&gt;&#123;$error_message&#125;&lt;/b&gt;, 在文件&lt;font style=&apos;color:red&apos;&gt;&#123;$error_file&#125;&lt;/font&gt;中， 第&#123;$error_line&#125;行。&lt;br&gt;&quot;; &#125; getType($a); echo &quot;1111111111111111&lt;br&gt;&quot;; getType(); echo &quot;222222222222222222222&lt;br&gt;&quot;; echo &quot;--------------------------------------------&lt;br&gt;&quot;; echo $mess;?&gt; 错误日志一般地，程序都会保存错误日志，用来记录程序运行时的错误信息。且错误日志都有其默认的存储位置。对于错误信息和错误日志的位置，我们都可以进行修改 在PHP.ini配置文件中，有以下几项可以对错误日志进行设置 error_reporting = E_ALL //将向PHP发送每个错误 display_errors=Off //不显示错误报告 log_errors=On //决定日志语句记录的位置 log_errors_max_log=1024 //每个日志项的最大长度 error_log=G:/myerror.log //指定错误写进的文件 在php文件中，我们可以使用函数error_log()来自定义错误信息 &lt;?php error_log(&quot;登录失败了！&quot;); ?&gt; 异常处理异常(Exception)处理用于在指定的错误发生时改变脚本的正常流程，是PHP5中的一个新的重要特性。异常处理是一种可扩展、易维护的错误处理机制，并提供了一种新的面向对象的错误处理方式 123456789101112131415161718192021222324252627&lt;?phpclass Exception&#123; protected $message = &apos;Unknown exception&apos;; // 异常信息 private $string; // __toString cache protected $code = 0; // 用户自定义异常代码 protected $file; // 发生异常的文件名 protected $line; // 发生异常的代码行号 private $trace; // backtrace private $previous; // previous exception if nested exception public function __construct($message = null, $code = 0, Exception $previous = null); final private function __clone(); // Inhibits cloning of exceptions. final public function getMessage(); // 返回异常信息 final public function getCode(); // 返回异常代码 final public function getFile(); // 返回发生异常的文件名 final public function getLine(); // 返回发生异常的代码行号 final public function getTrace(); // backtrace() 数组 final public function getPrevious(); // 之前的 exception final public function getTraceAsString(); // 已格成化成字符串的 getTrace() 信息 // Overrideable public function __toString(); // 可输出的字符串&#125;?&gt; [注意]如果使用自定义的类来扩展内置异常处理类，并且要重新定义构造函数的话，建议同时调用parent::construct()来检查所有的变量是否已被赋值。当对象要输出字符串的时候，可以重载toString() 并自定义输出的样式 12345678910111213141516171819&lt;?php /* 自定义的一个异常处理类，但必须是扩展内异常处理类的子类 */ class MyException extends Exception&#123; //重定义构造器使第一个参数 message 变为必须被指定的属性 public function __construct($message, $code=0)&#123; //可以在这里定义一些自己的代码 //建议同时调用 parent::construct()来检查所有的变量是否已被赋值 parent::__construct($message, $code); &#125; public function __toString() &#123; //重写父类方法，自定义字符串输出的样式 return __CLASS__.&quot;:[&quot;.$this-&gt;code.&quot;]:&quot;.$this-&gt;message.&quot;&lt;br&gt;&quot;; &#125; public function customFunction() &#123; //为这个异常自定义一个处理方法 echo &quot;按自定义的方法处理出现的这个类型的异常&lt;br&gt;&quot;; &#125; &#125;?&gt; 12345678910111213&lt;?php try &#123; //使用自定义的异常类捕获一个异常，并处理异常 $error = &apos;允许抛出这个错误&apos;; throw new MyException($error); //创建一个自定义的异常类对象，通过throw语句抛出 echo &apos;Never executed&apos;; //从这里开始，try代码块内的代码将不会再被执行 &#125; catch (MyException $e) &#123; //捕获自定义的异常对象 echo &apos;捕获异常: &apos;.$e; //输出捕获的异常消息 $e-&gt;customFunction(); //通过自定义的异常对象中的方法处理异常 &#125; echo &apos;你好呀&apos;; //程序没有崩溃继续向下执行?&gt; 好的代码像粥一样，都是用时间熬出来的作者：小火柴的蓝色理想 来自：http://www.cnblogs.com/xiaohuochai/p/6087997.html]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS 互联网世界的安全基础]]></title>
    <url>%2F2016%2F10%2F15%2Fhttps-safety%2F</url>
    <content type="text"><![CDATA[近一年公司在努力推进全站的 HTTPS 化，作为负责应用系统的我们，在配合这个趋势的过程中，顺便也就想去搞清楚 HTTP 后面的这个 S 到底是个什么含义？有什么作用？带来了哪些影响？毕竟以前也就只是模糊的知道大概是更安全，但到底怎么变得更安全的，实际上整个细节和流程并没有掌握的特别清晰。 所以这篇关于 HTTPS 的技术总结文章，主要提供一个关于 HTTPS 中的 S 一个整体的认识。从其产生的历史背景、设计目标说起，到分析其协议设计结构、交互流程是如何实现其目标。最后结合我们自己的案例分析下其中带来的影响。 下面我们就先从其诞生之初说起吧。 历史S 代表 Secure，所以 HTTPS 自然就是更安全的 HTTP 的意思。互联网诞生之初 SSL（Secure Sockets Layer 安全套接层）是由 Netscape 这家最早的浏览器公司设计的，主要是用于 Web 的安全传输的协议，这种协议在早期 Web 上获得了广泛的应用。后来被 IETF 标准化形成了 TLS（Transport Layer Security 传输层安全）标准，其历史如下： 1994: SSL1.0，因为存在严重的安全漏洞，未发布。 1995: SSL2.0，这个版本由于设计缺陷，很快被发现有严重漏洞，被废弃。 1996: SSL3.0，重新设计并开始流行，SSL 前三个版本都是由 Netscape 设计实现。 1999: TLS1.0，IETF 将 SSL 标准化，即 RFC 2246。 2006: TLS1.1，作为 RFC 4346 发布。 2008: TLS1.2，作为 RFC 5246 发布 。 2015: TLS1.3，尚在制定中，处于草案阶段。 如上，现在互联网世界使用最广泛的应该是 TLS1.2 标准。 目标SSL/TLS最初的设计目标就是为了实现下面三个目的： 保密：第三方无法窃听。 完整：无法篡改。 认证：防止身份冒充。 互联网是一个开放的环境，十分复杂。网上两端通信的双方彼此都不知道谁是谁，双方如何信任、信息如何保密，如何不被篡改，这是十分复杂的问题。而且互联网本身就像有生命一般在不断进化，如何设计一个协议来应对未来可能的变化，因而这使得SSL/TLS协议的设计十分复杂。 结构我们知道整个互联网构建于TCP/IP协议栈基础之上，在描述协议设计细节之前，我们先看看SSL/TLS协议处于该分层协议栈结构中的位置，其分层结构位置参考如下： 交互SSL/TLS协议设计之初就考虑了互联网和安全算法生命周期的演变，所以设计了一个算法协商握手流程，允许未来随着新安全算法的诞生可以灵活的加入到协议中，这就是典型的软件可扩展性设计的范例。下面是协议握手流程： 握手的目的简单概括就是：通信双方协商出一套会话密钥，然后基于此密钥通过对称加密方式来安全通信。 Client Hello握手交互流程，首先由 Client 端发起ClientHello请求。在这个请求中 Client 端向 Server 端提供如下信息： SSL version : 自己支持的最高协议版本，比如 TLS1.2。 Ciphers : 支持的加密套件，比如：RSA非对称加密算法，AES对称加密算法。 Random number: Client 端随机数，将会用来生成会话密钥。 Server HelloServer 收到ClientHello请求后需要回应一系列内容，从ServerHello到ServerHelloDone，有些服务端的实现是每条单独发送，有些服务端实现是合并到一起发送。 ServerHello根据 Client 端的请求信息确认使用的协议版本和加密套件（Cipher Suite），和客户端一致，并生成一个 Server 端随机数，用来生成会话密钥。 CertificateServer 端用于证明自身身份的凭证，一种由专门的数字证书认证机构（Certificate Authority 简称 CA）通过非常严格的审核之后颁发的电子证书，由 Client 端去认证 Server 端的合法身份。 ServerKeyExchange可选的，补充生成会话密钥的信息。对于前面协商的有些加密算法若Certificate未提供足够的信息或就没有 Certificate那么需要发送该消息。进一步的细节我们就不深入了，可以查看参考[1]。 CertificateRequest可选的，Server 端需要认证 Client 端身份的请求时发送。比如，银行提供的各类 U 盾，其实就是一种 Client 证书，一般在线使用专业版网银时才需要。 ServerHelloDone表示 Server 响应结束。 Client FinishedClient 收到 Server 回应后，首先验证 Server 的证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，Client 会继续回应 Server，包括如下内容： CertificateClient 端响应 Server 的CertificateRequest请求。 ClientKeyExchangeClient 再生成一个随机数，又称premaster secret用于生成会话密钥的信息，并把这个随机数传递给 Server 用于 Server 生成相同的会话密钥。 CertificateVerify用于对客户端证书提供证明，对于特定的证书需要可选发送。 ChangeCipherSpec用于告知 Server，Client 已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件和会话密钥加密数据并传输了。 FinishedClient 会使用之前协商好的加密套件和会话密钥加密一段Finished的数据传送给 Server，此数据是为了在正式传输应用数据之前对刚刚握手建立起来的加解密通道进行验证。 Server FinishedServer 在接收到客户端传过来的premaster secret数据之后，也会使用跟 Client 同样的方式生成会话密钥。一切就绪后，服务端回应如下内容： NewSessionTicket表示新建了一个会话票据，传递给 Client。若连接意外中断 Client 需要重建会话时，可以复用该票据，加速握手过程。 ChangeCipherSpec告知 Client 已经切换到协商过的加密套件状态，准备使用加密套件和会话密钥加密数据并传输了。 FinishedServer 会使用之前协商好的加密套件和会话密钥加密一段Finished的数据传送给 Client，此数据是为了在正式传输应用数据之前对刚刚握手建立起来的加解密通道进行验证。 至此，整个握手阶段全部结束。接下来 Client 和 Server 进入使用会话密钥的加密通信过程。 认证前面提及证书验证部分属于SSL/TLS协议中比较复杂的部分，我们单独用一节分析下。证书是由 CA 签发的，所以要验证证书的有效性需要去 CA 的服务器，流程如下。 在线证书状态验证采用了 OCSP（Online Certificate Status Protocol 在线证书状态协议）协议去验证。但如果按上面这个方式，那 HTTPS 就慢死了，不实用，所以有了 OCSP stapling 方式，其流程如下： Server 端会定期去 CA 同步一份经过 CA 认证签名的证书状态检查结果并伴随ClientHello响应返回给 Client 端。因为这个结果是 CA 自己通过数字签名，Server 也无法伪造或篡改，因此 Client 可以信任这个结果，以达到减少不必要的步骤提升性能的效果。 另外，证书根据其认证类型可分为三类： Domain ValidationDV 证书用于验证一个或多个域名的所有权，无需递交纸质文件，仅验证域名管理权，无需人工验证申请单位真实身份。 Organization ValidationOV 证书用于验证此域名由特定组织或单位所拥有的域名。申请此类证书，通过证书颁发机构审查网站企业身份和域名所有权以证明申请单位是一个合法存在的真实实体，CA 机构将在人工核实后签发证书。 Extended ValidationEV 证书是目前最高信任级别的证书。通过极其严格甚至苛刻审查网站企业身份和域名所有权，确保网站身份的真实可靠。 我们经常通过浏览器访问一些安全级别比较高的网站时，都是基于 HTTPS 协议，这时浏览器会显示一个绿色的「锁型」标记，让我们心理感到放心，比如下图所示几个例子： 招行 支付宝 GitHub 上面三个图，分别来自招商银行、支付宝和 GitHub，看出它们的证书和加密套件的区别没？其中招行和 GitHub 都是采用的 EV 证书，所以浏览器地址栏显示了企业名称，而支付宝采用的是 OV 证书因此没有。另外招行的 TLS 协议是 1.0 版本，这是一个有已知安全漏洞的版本，浏览器提示了过时的连接安全设置。而支付宝采用的加密套件被提示属于过时的（强度不是最高的，但没有已知的安全漏洞），GitHub 采用的则应该是目前最推荐的安全加密算法套件：TLS1.2（协议版本） + ECDHE_RSA（密钥协商交换） + AES_128_GCM（对称加密）。 另外，SSL/TLS协议中比较复杂的部分是关于加密套件的，这块基本属于密码学背后的数学原理部分。一般码农基本搞不懂（我也搞不懂），对于我们来说大概只需要搞清楚对称加密、非对称加密、HASH 算法的区别和时间开销。在选择密码套件时知道哪类是哪类，跟上主流的选择就行了。 案例讲完SSL/TLS的基本原理和交互流程，就以我所在的 IM 项目为例，这里同时涉及 HTTP + S 和 TCP + S。HTTP 属于全公司一起加 S，那就加在统一的负载均衡层，也就是 HAProxy 那里，对整体应用无影响（参见下面部署结构图）。而 IM 客户端应用也可以间接通过 HTTPS 前置请求获得对服务端的认证，然后选择接入服务器建立 TCP 长连接。TCP 长连接实际只需要做加密保护，不再需要二次认证。 一开始，我们是在自己的接入应用中，基于 JDK 的 SSL 库实现的 TCP + S，但是发现在高并发压力下发现性能衰退的厉害，后来便改成了使用 Nginx 前置接入的方式。对比性能测试如下所示： 可以看出引入 SSL 后确实带来了一些性能开销，不过整体不大。 总结至此，我们基本把 HTTPS 涉及的SSL/TLS相关的内容整体而粗浅的探讨了一番，至于更细节的一些内容，大家若有兴趣可以去看 RFC 和下面的一些参考资料。 参考[1] byronhe TLS协议分析与现代加密通信协议设计. 2015.09 [2] Baidu 全站HTTPS时代的号角：大型网站的HTTPS实践系列. 2015.04 [3] seanlook SSL/TLS原理详解. 2015.1 [4] 阮一峰 SSL/TLS协议运行机制的概述. 2014.2 [5] MaxCDN What is OCSP Stapling? 作者：mindwind 来自：http://www.cnblogs.com/mindwind/p/6082795.html]]></content>
      <tags>
        <tag>HTTPS</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遇见程序员男友]]></title>
    <url>%2F2016%2F10%2F12%2Fmeet%2F</url>
    <content type="text"><![CDATA[“你爱我吗？” “爱。” “有多爱？” “比爱1024还爱你。” 听到这句话，我有过1024次拍死我的程序员男友的冲动，最终看在他脸上写满诚恳的样子的份上，还是只朝他撇了撇嘴。 如你所看见的，我的男朋友是一名程序员，一名因为长期写代码而会让人产生连他的那张脸上也写满代码的错觉的程序员。 遇见他之前，我并不太明白程序员是什么东西，对于他自称的“极客”，更是一脸茫然。 “极客？什么玩意，跟黑客一样破坏世界的吗？” “其实那些你们认为的破坏分子不叫黑客，而叫骇客……”balabalabala，接下来他给我做了长达N分钟的解释说明。 “好吧，不懂。那你有没有做过破坏世界的事啊？” “我都说了黑客不是骇客而且我是极客……如果有的话？侵入教务系统算不算？” “你侵入教务系统修改了你的成绩？” “没有，只是下载了几张女生照片而已啦……” “你……好猥琐啊。” 有一个程序员男友最直接的好处便是他可以承包你一切电子产品的故障维修工作，虽然他总是义正言辞地将他自己和修理工区分开来，但这并不意味着他可以挣脱成为我的御用修理工的命运。那还是我们才认识不久大约勉强算得上熟识的时候。 “对了，你不是程序员嘛。你会修电脑吗？我电脑好像有点问题。” “那个，程序员不一定会修电脑……我们也不是修电脑的。不过，我还是可以帮你看一看。” “你难道不知道很多帮女生修电脑的男程序员修着修着就修改了找不到对象的传说了？” “额，这个，这个……” 不知道是不是所有的程序员都能这样找到真爱，但我想这样找到的对象一定都是真爱。 “我喜欢字写的漂亮的男生，字写得好的男生遭人爱。” “长得好的男生也遭人爱……” “对啊，但是你都不是。” “为什么就没有女生欣赏代码写得好的男生呢？” “你去找一个同样喜欢写代码的女生吧……” 他是一个把编程当做游戏能编上瘾的，标准的程序员。和他在一起之后做的最多的便是搬着我的电脑在他旁边看他敲代码：我开始看电影的时候他在敲代码，我看完电影的时候他还在敲代码；我酝酿情绪准备写东西的时候他在敲代码，我写完东西对着电脑屏幕发呆的时候他还在旁边念念有词的敲代码。 “啊，这个好帅啊。” 当他嘴里发出这样的话的时候，我下意识地转过头去看他，却（发现）原来他正对着一群代码自言自语。不过时间久了，也就习惯了。大约正如我喜欢在一个人的时候吟一些唐诗宋词一般，他亦喜欢跟他的代码对话吧。而作为一个资深的技术宅，他身上的关键字不是“技术”，而是“宅”。宅到无以复加，宅到忍无可忍。 “今天出去玩吧。” “怎么想到要出去玩了？” “额……学校不是要停电吗？” 不知道是他比较内向的缘故，还是他们这一类人都活在自己的世界里。他不爱与人打交道，相对于复杂的人际关系来说，大约他更愿意埋在那一窜乱码般的代码里吧。比如一起吃饭的时候跟服务员交流这样一件事，他就总是要全权地交付于我。仿佛我成了他与这个现实世界的唯一链接。 “只是觉得，嗯……有你就够了啊。” 这当然是一句动听的情话，而事实上多多少少也确实如此吧。他可以一个人过得很好，而当他下定决心将他的世界大门向你打开，将他的世界与你分享之时，他便也将你当做了他世界的一部分。虽然他不会明白你那些不为人知的小心思，但是他会真正的把你放在心上，至少，他愿意为你处理那些你不擅长的技术琐事，即使那些问题在他的眼里可能白痴的要命，甚至是浪费自己的天赋。 “亲，我想教你编程。” “这个，这个。我的理科是体育老师教的，这辈子我应该都学不会吧……” “不会啊，你很聪明。” 虽然，那好像是他极少数夸我聪明的次数之一。虽然，最后我也只是看了一看他帮我借的一本书的前言。或许，那也是他试图向你分享他的世界的表现之一吧。 在我眼里的他的世界是杂乱无章的，当然我不得而知他电脑深处的另一个世界是否井然有序。每每气急败坏（说）他的邋遢的时候，他的脸上总会呈现出一副Sherlock式的傲娇的神情，让我无可奈何。我相信不是所有的程序员都这样不爱收拾自己，但这似乎也并改不了程序员总还是逃不过被和邋遢的IT民工联系在一起的命运，也只能在无可奈何之时叹一句大约他们的智商不在此了。他对自己的衣着打扮毫不在意，从来不会知道他自己适合穿什么样的衣服，和他谈论的时候也永远只是一句：“反正你买就好了，你买什么我穿什么。”——但这并不妨碍他对我的衣着打扮评头论足。 在别人眼里，或者说不熟的人的眼里，他看起来永远是一副呆滞模样，闷声不吭，脸上爬满代码。“那时候我们都可好奇了，他这样几乎不说话的人，是怎么追到女朋友的。” “哈哈。其实我也觉得很神奇，就这么在一起了。” 熟识之后知晓其实他也同大部分人一样，在熟人堆里话从来也不少。不乏有一旦得到别人响应便滔滔不绝之势，或许是平日里志同道合之人甚少，一旦得见大有秉烛夜谈之劲，大约也正是相谈甚欢之人的缺失，才让人有对着代码对话的冲动吧。不过他懂得很多，听他絮絮叨叨是一件挺幸福的事儿。其实每个人都一样，都有这样一种表达欲，所谓不遇知音懒吟诗是也。 他们喜欢做他们自己国度里的国王，主宰着属于他们自己的世界。 他对电子产品有一种特殊的迷恋。我想很多科技界的人士都有这样的通病吧，如同在数字尾巴上时常看到的“搞机”一族。对物质生活并不太关心的他，更愿意花大把大把的钱在科技产品之上。相比于中午应该吃什么美味的午餐，他更关心谷歌新出那款眼镜有什么功能性价比如何。他也经常同我讲新科技、新设计之类，试图给我建立起一个全新的跟得上时代步伐的科技观。在他对电子产品的无限热衷的感染之下，久而久之倒也欣然接受，成了周围同学眼里的科技通，“跟他在一起，你仿佛懂了很多的样子。”虽然偶尔对于他毫无节制的“败家”，我还是会有所微词。 “你应该多写一点东西，这样网站才有更多的访问量，你也不会成日里无所事事。” 他又开始教训我了，大约是比我大一点的缘故，总会有几分像父亲，像兄长，睿智、成熟，却又唠叨、爱训斥。 当然，有时候，也会是体贴的男友，会是温柔的情人，还会是卖萌的儿子。 虽然，他是个程序员，但毕竟，他是我男友嘛。 来自：http://kb.cnblogs.com/page/207265/]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5 和 ES6 class]]></title>
    <url>%2F2016%2F10%2F11%2FECMAScript%2F</url>
    <content type="text"><![CDATA[ECMAScript 6 目前基本成为业界标准，它的普及速度比 ES5 要快很多，主要原因是现代浏览器对 ES6 的支持相当迅速，尤其是 Chrome 和 Firefox 浏览器，已经支持 ES6 中绝大多数的特性。 这次就来说说ES5与ES6里class的区别： ES5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function User(name,age) &#123; this.name = name; this.age = age;&#125;// 静态方法User.getClassName = function()&#123; return &apos;User&apos;&#125;User.prototype.changeName = function(name)&#123; this.name = name&#125;User.prototype.changeAge = function(Age)&#123; this.Age = Age&#125;Object.defineProperty(User.prototype,&apos;info&apos;,&#123; get()&#123; return &apos;name&apos;+this.name+&apos;age&apos;+this.age &#125;&#125;)// 子类function Manager(name,age,password)&#123; User.call(this,name,age); this.password = password&#125;// 继承静态方法Manager.__proto__ = User// 继承原型方法Manager.prototype = User.prototype;//添加新方法Manager.prototype.changePassword = function(pwd)&#123; this.password = password&#125;var manager = new Manager(&apos;leo&apos;,22,&apos;123&apos;);manager.changeName(&apos;zengliang&apos;);console.log(User.name) //Userconsole.log(manager.name) //zengjiangfunction test()&#123; console.log(&quot;1&quot;)&#125;console.log(test.name) //test ES612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// function User(name,age) &#123;// this.name = name;// this.age = age;// &#125;class User &#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; // // 静态方法 // User.getClassName = function()&#123; // return &apos;User&apos; // &#125; static getClassName()&#123; return &apos;User&apos; &#125; // 方法的定义 // User.prototype.changeName = function(name)&#123; // this.name = name // &#125; // User.prototype.changeAge = function(Age)&#123; // this.Age = Age // &#125; changeName(name)&#123; this.name = name &#125; changeAge(age)&#123; this.age = age &#125; // 自定义属性 // Object.defineProperty(User.prototype,&apos;info&apos;,&#123; // get()&#123; // return &apos;name&apos;+this.name+&apos;age&apos;+this.age // &#125; // &#125;) get info()&#123; return &apos;name&apos;+this.name+&apos;age&apos;+this.age &#125;&#125;// 子类// function Manager(name,age,password)&#123;// User.call(this,name,age);// this.password = password// &#125;class Manager extends User&#123; // 和call的区别，call先创建自身对象 constructor(name,age,password)&#123; // super先创建父对象 必须 super(name,age); this.password = password &#125; // //添加新方法 // Manager.prototype.changePassword = function(pwd)&#123; // this.password = password // &#125; changePassword(password)&#123; this.password = password &#125; get info()&#123; var info = super.info; console.log(info) &#125;&#125;// 下面的静态方法跟原型方法已经继承了，无须写其他的// // 继承静态方法// Manager.__proto__ = User// // 继承原型方法// Manager.prototype = User.prototype;console.log(typeof User,typeof Manager)//function function// var manager = new Manager(&apos;leo&apos;,22,&apos;123&apos;);// manager.changeName(&apos;zengliang&apos;);// console.log(User.name) //User// console.log(manager.name) //zengjiang// function test()&#123;// console.log(&quot;1&quot;)// &#125;// console.log(test.name) //test 不会提升12345678910111213141516// // 立即执行// let user = new class User&#123;// constructor(name)&#123;// this.name = name// &#125;// &#125;(&apos;zengliang&apos;);// console.log(user)// 会报错，因为不会提升// var user = new User()// class User&#123;// constructor(name)&#123;// this.name = name// &#125;// &#125; 来自：http://www.cnblogs.com/mr-pz/p/6056420.html]]></content>
      <tags>
        <tag>ES5</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie入门]]></title>
    <url>%2F2016%2F10%2F10%2Fcookie%2F</url>
    <content type="text"><![CDATA[据我对cookie诞生背景的了解，cookie是由网景公司创建的，目的就是将用户的数据储存在客户端上。伴随的HTML5的出现，现在又有另外一个解决数据离线储存的方案，就是HTML5中的Web storage，其中两个重要对象sessionStorage和localStorage可以解决浏览器sessions和长期储存数据的目的，并且兼容性还不错，IE8+以上浏览器都支持。 那我们直接学习Web storage不就可以了？个人认为，这不是一个很好的学习方法。Web Storage的出现主要还是因为cookie的一些小毛病不能够满足前端工程师日常开发而被加入到HTML5中作为新的API的。本质上说，localStorage和sessionStorage实现的本质与cookie是一样的。所以在接触之前，先熟悉并且掌握cookie对于Web storage的学习还有很大的帮助。 这篇文章会涉及的内容与技术： module bundler：webpack javascirpt如何实现读取，写入，删除Cookie js-cookie实现读取，写入，删除Cookie cookie定义cookie其实就是服务器保存在浏览器的一小段文本信息。怎么保存呢？浏览器在向服务器发送一个http请求时，会在发送请求的首部字段中添加Cookie字段，并且附上相应的key，value。服务器接收到请求并且正确返回响应的时候，会在响应的头部字段中添加Set-cookie字段。这时候就完成了一次数据储存的操作。当我们关闭浏览器并且再次打开的时候，相应需要存储的信息就会在expires指定的期限内存储下来。 简单的说，就是： 当用户访问web页面时，他的记录可以保存在cookie中。 在用户下一次访问同一页面时，可以在cookie中读取用户的访问记录。 cookie特点 每个cookie的大小不能超过4KB。 通过HTTP协议的方式来存储数据。 cookie会影响同一域名下的根目录及其子目录。举例来说，如果当前URI是keithchou.github.io，如果设置path为’/‘或者不设置（默认值为/），这个cookie对该域名的根路径和它的所有子路径都有效。如果path设置为/music，那么这个cookie只有在访问keithchou.github/music及其子路径才有效。 同源政策。浏览器的同源政策规定，两个网址只要域名和端口相同，就可以共享cookie。注意，这里不要求协议相同。也就是说，’http://keithchou.com&#39;设置的cookie，可以被&#39;https://keithchou.com&#39;读取。 cookie属性cookie常用的属性有： value domain path expires secure HttpOnly 属性的具体内容就不再赘述了，属性都比较简单。 cookie实现接下来想说说两种方式来实现cookie。一是原生javascript实现cookie，二是通过js-cookie这个小框架来实现cookie。 javascript实现数据存储基本的cookie操作有三种：读取、写入和删除。javascript操作cookie主要是通过document.cookie来实现的。 document.cookie的一大特点是，可以读取所有的Cookie，但是每次写入cookie的时候只能一条一条写入。看一个从百度获取的cookie。 123456789//读取cookie，一次性获取所有cookie。 console.log(document.cookie);//每个cookie都是以键值对的形式存在，并且通过；分隔。&quot;BAIDUID=9BD404162B2978E266B82B0D052A12D7:FG=1; BIDUPSID=605A0EB7E85170299BCFFF6C2B042840; PSTM=1474937533; BD_UPN=13314752; ispeed_lsm=6; BDRCVFR[Fc9oatPmwxn]=G01CoNuskzfuh-zuyuEXAPCpy49QhP8; BD_HOME=0; H_PS_PSSID=1440_21421_18240_21116_21454_21377_21526_21191_21399; BD_CK_SAM=1; PSINO=7; H_PS_645EC=9c44kg7jUnDfYs5vfqg9n3QbElgAvuf8phS5ZsmD2FIE2KxSARX534GRQw1z7f0cZ6wu; locale=zh; pgv_pvi=4703388672; pgv_si=s5301332992&quot;//写入cookie，只能一条一条写入。document.cookie = &apos;unclekeith=21&apos;;document.cookie = &apos;sex=boy&apos;; 原生javascript实现cookie的方法如下。此代码摘自《javascript高级程序设计 第三版》。 123456789101112131415161718192021222324252627282930313233343536373839var CookieUtil = &#123; //读取cookie，判断某个cookie是否存在。 //读取操作配合 unclekeith=21; sex=boy 这个cookie会更好理解读取cookie的操作。 get: function (name)&#123; var cookieName = encodeURIComponent(name) + &quot;=&quot;, cookieStart = document.cookie.indexOf(cookieName), cookieValue = null; if (cookieStart &gt; -1)&#123; var cookieEnd = document.cookie.indexOf(&quot;;&quot;, cookieStart); if (cookieEnd == -1)&#123; cookieEnd = document.cookie.length; &#125; cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); &#125; return cookieValue; &#125;, //写入cookie。 set: function (name, value, expires, path, domain, secure) &#123; var cookieText = encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value); if (expires instanceof Date) &#123; cookieText += &quot;; expires=&quot; + expires.toGMTString(); &#125; if (path) &#123; cookieText += &quot;; path=&quot; + path; &#125; if (domain) &#123; cookieText += &quot;; domain=&quot; + domain; &#125; if (secure) &#123; cookieText += &quot;; secure&quot;; &#125; document.cookie = cookieText; &#125;, //删除cookie unset: function (name, path, domain, secure)&#123; this.set(name, &quot;&quot;, new Date(0), path, domain, secure); &#125; &#125;; javascript实现cookie的代码并不复杂，只要有javascript基础，基本上都可以看懂。给出原生javascript实现cookie的操作是因为要去实际的了解一下整个过程，不然使用前端大牛封装好的库来实现cookie总感觉有一些东西特别难以理解。 js-cookie首先我想说的是，网上大量的资料都是对$.cookie进行介绍的。官网明确指出这个项目已经不再继续维护了。为什么还要使用阿？所以不再介绍。这里要介绍另外一个实现cookie的库。js-cookie。具体的api在官网上有详细的介绍。传送门：js-cookie 首先，进入本地项目，通过cnpm安装js-cookie。 cnpm install js-cookie --save 然后，在使用webpack中的入口文件entry.js引入js-cookie。 import Cookies from &apos;js-cookie&apos;; 当然，接下来就可以使用了。下面是一个登录界面的小demo。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546html部分&lt;p&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&apos;username&apos; name=&apos;username&apos; placeholder=&quot;请输入用户名&quot;&gt;&lt;/p&gt;&lt;p&gt; &lt;label for=&quot;password&quot;&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; id=&apos;password&apos; name=&apos;password&apos; placeholder=&quot;请输入密码&quot;&gt;&lt;/p&gt;&lt;p&gt; &lt;label for=&quot;confirm_password&quot;&gt;再次输入密码：&lt;/label&gt; &lt;input type=&quot;password&quot; id=&apos;confirm_password&apos; name=&apos;confirm_password&apos; placeholder=&quot;再次输入密码&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&apos;rememberUser&apos;&gt; &lt;label for=&quot;rememberUser&quot;&gt;记住用户名&lt;/label&gt;&lt;/p&gt;//js部分//先判断浏览器是否储存有对应的cookie。if (Cookies.get(&apos;username&apos;)) &#123; $(&quot;#username&quot;).val(Cookies.get(&apos;username&apos;)); $(&apos;#rememberUser&apos;).attr(&apos;checked&apos;,true);&#125;;if (Cookies.get(&apos;password&apos;)) &#123; $(&apos;#password&apos;).val(Cookies.get(&apos;password&apos;)); $(&apos;#confirm_password&apos;).val(Cookies.get(&apos;password&apos;));&#125;//设置cookie。当点击 记住用户名 操作时储存相应的数据。$(&apos;#rememberUser&apos;).click(function()&#123; if (this.checked) &#123; if ($(&apos;#username&apos;).val() ===&apos;&apos;) &#123; alert(&apos;请输入用户名&apos;); this.checked = false; &#125; else &#123; Cookies.set(&apos;username&apos;,$(&apos;#username&apos;).val(),&#123; path:&apos;/&apos;, expires: 1 &#125;); Cookies.set(&apos;password&apos;,$(&apos;#password&apos;).val(),&#123; path:&apos;/&apos;, expires: 1 &#125;) &#125; &#125;&#125;); 作者：unclekeith 来自：http://www.cnblogs.com/Uncle-Keith/p/6069537.html]]></content>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window的对象有哪些]]></title>
    <url>%2F2016%2F10%2F10%2Fobject%2F</url>
    <content type="text"><![CDATA[window的主对象主要有如下几个：document 对象； frames 对象； history 对象； location 对象； navigator 对象； screen 对象； 全局变量和函数都是window的属性。 window的窗体函数：open() 函数：打开(弹出)一个新的窗体； close() 函数：关闭窗体； opener 属性：通过opener可以实现跨窗体之间的通讯，但是要保证是在同一域名下，而且一个窗体要包含另一个窗体的opener。 window.open(url, name, features, replace); open函数参数说明： url – 要载入窗体的URL； name – 新建窗体的名称(也可以是HTML target属性的取值，目标)； features – 代表窗体特性的字符串，字符串中每个特性使用逗号分隔； replace – 一个布尔值，说明新载入的页面是否替换当前载入的页面，此参数通常不用指定。 对话框函数：alert() 函数； confirm() 函数：返回boolean值； prompt(str1,str2) 函数：可输入对话框（“此处str1不能编辑”、“str2可以编辑”）。 定时器常用函数： 时间等待与间隔函数： setTimeout(a,b) 函数，指定时间之后执行的方法。a为要执行的方法，b为时间间隔，单位毫秒。 clearTimeout(i) 函数，清除指定的setTimeout函数执行，例：var i=setTimeout(a，b)。 setInterval(a,b) 函数，每隔时间b循环执行a； clearInterval(i) 函数，清除定时器，例：var iu=setInterval。 window.location对象解析URL对象location location对象的属性有：href,protocal,host,hostname,port,pathname,search,hash 12345678document.write(location.href + &quot;&lt;br/&gt;&quot;); // http://localhost:4889/javascriptTest.htmldocument.write(location.protocol + &quot;&lt;br/&gt;&quot;); // http:document.write(location.host + &quot;&lt;br/&gt;&quot;); // localhost:4889document.write(location.hostname + &quot;&lt;br/&gt;&quot;); // localhostdocument.write(location.port + &quot;&lt;br/&gt;&quot;); // 4889document.write(location.pathname + &quot;&lt;br/&gt;&quot;); // /javascriptTest.htmldocument.write(location.search + &quot;换行&lt;br/&gt;&quot;); //http://localhost:4889/javascriptTest.html?id=1&amp;name=张三 如果路径是这样，则输出 ?id=1&amp;name=%E5%BC%A0%E4%B8%89document.write(location.hash); //http: //localhost:4889/javascriptTest.html#kk=你好?id=1&amp;name=张三 如果路径是这样，则输出 #kk=你好?id=1&amp;name=张三 作者：xie_yi 来自：http://www.cnblogs.com/xie-yi/p/6049937.html]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlexBox标准及兼容写法速查表]]></title>
    <url>%2F2016%2F10%2F08%2FflexBox%2F</url>
    <content type="text"><![CDATA[FlexBox标准写法:支持浏览器：IE11，Chrome29+，FireFox 20+，Safari加前缀-webkit- 概述： 总的来说就是12个属性； 关于容器的6个，5个单一属性，分别定义了元素排列的方向，行，水平排列，垂直排列，空白分布，和一个简写属性，方向，行 关于容器内元素的6个，5个单一属性，分别定义元素的顺序，伸展，收缩，初始尺寸，对齐，和一个简写属性描述元素尺寸 container : display: flex / inline-flex; 说明 flex-direction: row / column / row-reverse / column-reverse 元素在容器内的排列方向 flex-wrap: nowrap / wrap / wrap-reverse 元素一行或多行显示 flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt; default: &lt;row nowrap&gt; 上面两个属性的简写 justify-content: flex-start / flex-end / center / space-between / space-around 水平方向上, 元素在容器内的分布 align-items: stretch / flex-start / flex-end / center / baseline 垂直方向上, 元素在容器内的分布 align-content: stretch / flex-start / flex-end / center / space-between / space-around 在容器内, 额外的空白部分的分布 Container items : order: &lt;number&gt; 0 元素在容器内的排列顺序 align-self: auto / flex-start / flex-end / center / baseline / stretch 覆盖align-items的值, 定义自身在垂直方向上的分布 flex-grow: &lt;number&gt; 0 元素在容器内所占空间的伸展 flex-shrink: &lt;number&gt; 1 元素在容器内所占空间的收缩 flex-basis: &lt;width&gt; auto 初始化时, 元素在容器内的尺寸 flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt; &lt;0 1 auto&gt; 上面三个属性的简写 以上&lt;number&gt;不支持负值; 每个属性的第一个取值为默认值; 蓝色为多个属性简写模式; 兼容IE10:加前缀 -ms- display:-ms-flexbox / -ms-inline-flexbox; standard (橙色为item属性) -ms-flex-direction : row / column / row-reverse / column-reverse flex-direction -ms-flex-wrap : none / wrap / wrap-reverse flex-wrap 不支持 flex-flow -ms-flex-pack : start / end /center / justify justify-content -ms-flex-align : stretch / start / end /center / baseline align-items -ms-flex-line-pack : start / end /center / baseline align-content -ms-flex-order : &lt;number&gt; order -ms-flex-item-align : stretch / start / end /center / baseline align-self -ms-flex : &lt;positive-flex&gt; &lt;negative-flex&gt; &lt;preferred-size&gt; // none flex : 0 0 auto IE10之前不建议使用,可以尝试用display:table; 关于Chrome,FireFox旧版本支持:FireFox:把-webkit-换成-moz-即可 container : display: -webkit-flexbox / -webkit-inline-flexbox; standard (橙色为item属性) -webkit-box-direction: normal / reverse-webkit-box-orient: horizontal / vertical | flex-direction不支持 | flex-wrap不支持 | flex-flow-webkit-box-pack: flex-start / flex-end / center / space-between / space-around | justify-content不支持 | align-content-webkit-box-align: stretch / flex-start / flex-end / center / baseline | align-items-webkit-box-ordinal-group:&lt;number&gt; | order-webkit-box-flex: &lt;number&gt; 1 | flex-grow-webkit-flex-shrink: &lt;number&gt; 0 | flex-shrink-webkit-flex-basis: &lt;width&gt; auto (无-moz-) | flex-basis-webkit-box: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt; &lt;1 0 auto&gt; | flex不支持 | align-self 参考:兼容多浏览器的预定义写法: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Advanced_layouts_with_flexbox 作者：iriszy 来自：http://www.cnblogs.com/iriszhang/p/6102524.html]]></content>
      <tags>
        <tag>CSS3</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在网页中，rem与px的换算]]></title>
    <url>%2F2016%2F10%2F08%2Frem-px%2F</url>
    <content type="text"><![CDATA[rem 是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。为什么web app要使用rem？1、实现强大的屏幕适配布局： iphone6一下出了两款尺寸的手机，导致的移动端的屏幕种类更加的混乱，记得一两年前做web app有一种做法是以320宽度为标准去做适配，超过320的大小还是以320的规格去展示，这种实现方式以淘宝web app为代表作，但是近期手机淘宝首页进行了改版，采用了rem这个单位，首页以内依旧是和以前一样各种混乱，有定死宽度的页面，也有那种流式布局的页面。 我们现在在切页面布局的使用常用的单位是px，这是一个绝对单位，web app的屏幕适配有很多中做法，例如：流式布局、限死宽度，还有就是通过响应式来做，但是这些方案都不是最佳的解决方法。 例如流式布局的解决方案有不少弊端，它虽然可以让各种屏幕都适配，但是显示的效果极其的不好，因为只有几个尺寸的手机能够完美的显示出视觉设计师和交互最想要的效果，其他布局如：固定宽度，viewport等都有相对缺陷。 而rem能等比例适配所有屏幕上面说过rem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小。 2、没有屏幕字体缩放问题： px像素会在某些浏览器设置页面缩放比的情况下，下字体不按比例缩放。rem是相对大小，没有这种问题 3、没有em多次使用计算麻烦的问题： em是相对于父元素的大小，当层级较多，需要使用时，容易遇到无法预知的风险，也麻烦，而rem统一相对根元素，没有这种弊端。 以下便是我在网页中对于rem和px进行转换时用到的js：当然在引入此处js的时候还需要把jQuery类库引入进去…12345678910111213$(function()&#123; var a=document.body.clientWidth; // 获取当前可视区域的宽度 var b = a / 750; // ios的宽度为750 var c = b * 6.25; // 默认html为16px，62.5%就是10px var d = c * 100 + &quot;%&quot;; document.getElementById(&quot;html&quot;).style.fontSize = d;&#125;) 作者：明明如月moon 来自：http://www.cnblogs.com/zzmoon/p/6101765.html]]></content>
      <tags>
        <tag>px</tag>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒子模型]]></title>
    <url>%2F2016%2F10%2F08%2Fbox%2F</url>
    <content type="text"><![CDATA[快递车上包裹盒子模型 盒子的特征： 每个盒子都有 边距、边框、填充、内容四个属性 CSS盒子模型 在浏览器中，把一个个html元素当成一个个盒子。把一个个盒子摆放到浏览器的窗口当中。 boder、padding、margin 都有top、right、bottom、left 四部分 盒模型属性 语法：width：&lt;length&gt; | &lt;percentage&gt; | auto | inherit 默认值：auto | inherit 适用于：除非置换内联元素，table-row, table-row-group之外的所有元素 继承性：无 动画性：当值为&lt;length&gt; | &lt;percentage&gt;时 计算值：指定的值 取值：auto： 无特定宽度值，取决于其它属性值 &lt;length&gt;： 用长度值来定义宽度。不允许负值 &lt;percentage&gt;： 用百分比来定义宽度。百分比参照包含块宽度。不允许负值 说明：检索或设置对象的宽度。 对于img对象来说，仅指定此属性，其height值将根据图片源尺寸等比例缩放。 对于盒模型规则，请参阅box-sizing属性。 对应的脚本特性为width。 1234567891011121314151617181920body&#123; padding: 0; margin: 0; width: 100%; height: 100%;&#125;div,span&#123; background-color: pink;&#125;.sample&#123; /*width: 200px;*/ width: 50%;&#125;span&#123; width: 50%;/*给 inline元素设置宽度是无效的*/&#125;&amp;lt;div class=&quot;sample&quot;&amp;gt;sample&amp;lt;/div&amp;gt;&amp;lt;br&amp;gt;&amp;lt;span&amp;gt;inline&amp;lt;/span&amp;gt; 最大宽度 语法：max-width：&lt;length&gt; | &lt;percentage&gt; | none 默认值：none 适用于：除非置换内联元素，table-row, table-row-group之外的所有元素 继承性：无 动画性：当值为&lt;length&gt; | &lt;percentage&gt;时 计算值：指定的值 取值：none： 无最大宽度限制 &lt;length&gt;： 用长度值来定义最大宽度。不允许负值 &lt;percentage&gt;： 用百分比来定义最大宽度。不允许负值 说明：设置或检索对象的最大宽度。 如果max-width属性的值小于min-width属性的值，max-width将会自动以min-width的值作为自己的值。 IE6尚不支持此属性 对应的脚本特性为maxWidth。 height — 高度 语法：height：&lt;length&gt; | &lt;percentage&gt; | auto | inherit 默认值：auto | inherit 适用于：除非置换内联元素，table-column, table-column-group之外的所有元素 继承性：无 动画性：当值为&lt;length&gt; | &lt;percentage&gt;时 计算值：指定的值 取值：auto： 无特定高度值，取决于其它属性值 &lt;length&gt;： 用长度值来定义高度。不允许负值 &lt;percentage&gt;： 用百分比来定义高度。不允许负值 说明：检索或设置对象的高度。 对于img对象来说，仅指定此属性，其width值将根据图片源尺寸等比例缩放。 对于盒模型规则，请参阅box-sizing属性。 对应的脚本特性为height。 min-height — 最小高度 语法：min-height：&lt;length&gt; | &lt;percentage&gt; 默认值：0 适用于：除非置换内联元素，table-row, table-row-group之外的所有元素 继承性：无 动画性：当值为&lt;length&gt; | &lt;percentage&gt;时 计算值：指定的值 取值：&lt;length&gt;： 用长度值来定义最小高度。不允许负值 &lt;percentage&gt;： 用百分比来定义最小高度。不允许负值 说明：检索或设置对象的最小高度。 如果min-height属性的值大于max-height属性的值，max-height将会自动以min-height的值作为自己的值。 IE6尚不支持此属性。IE6的变通实现方法请参考 最小高度min-height实现详解。 对应的脚本特性为minHeight。 来自：http://www.cnblogs.com/qq-757617012/p/6100880.html]]></content>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript使用封装]]></title>
    <url>%2F2016%2F10%2F08%2Fuseclosure%2F</url>
    <content type="text"><![CDATA[基本封装方法 请看下面的例子： 1234567891011121314151617181920212223242526272829var Person = function(name,age)&#123; this.name = name; this.age = age || &quot;未填写&quot;; this.hobbys = [];&#125;Person.prototype = &#123; sayName:function()&#123; console.log(this.name); &#125;, sayAge:function()&#123; console.log(this.age); &#125;, addHobby:function(hobbys)&#123; this.hobbys = this.hobbys.concat(hobbys); &#125;&#125;var person1 = new Person(&quot;Jane&quot;,&quot;20&quot;);var person2 = new Person(&quot;TabWeng&quot;,&quot;21&quot;);person1.addHobby([&apos;sing&apos;,&apos;drawing&apos;]);person2.addHobby([&apos;football&apos;,&apos;study&apos;,&apos;running&apos;]);person1.sayName();console.log(person1.hobbys.toString());person2.sayName();console.log(person2.hobbys.toString()); 运行结果： Jane sing,drawing TabWeng football,study,running 这在JavaScript创建对象中讲过，把可以共用的属性和方法写在原型上，需要每个实例各自都有的副本的属性和方法放在构造函数中。 现在有个问题，名称的输入不能有数字，要怎么解决呢？解决的方法可以写一个检查名称的函数，这个函数写在原型上。 1234567891011121314151617181920212223242526272829303132333435363738var Person = function(name,age)&#123; //校验名称 if(this.checkName(name))&#123; throw new Error(&quot;名字 &quot;+name+&quot; 不能存在数字&quot;); &#125; this.name = name; this.age = age || &quot;未填写&quot;; this.hobbys = [];&#125;Person.prototype = &#123; //校验函数 checkName:function(name)&#123; re = /\d/; return re.test(name); &#125;, sayName:function()&#123; console.log(this.name); &#125;, sayAge:function()&#123; console.log(this.age); &#125;, addHobby:function(hobbys)&#123; this.hobbys = this.hobbys.concat(hobbys); &#125;&#125;var person1 = new Person(&quot;Helen666&quot;,&quot;20&quot;);var person2 = new Person(&quot;TabWeng&quot;,&quot;21&quot;);person1.addHobby([&apos;sing&apos;,&apos;drawing&apos;]);person2.addHobby([&apos;football&apos;,&apos;study&apos;,&apos;running&apos;]);person1.sayName();console.log(person1.hobbys.toString());person2.sayName();console.log(person2.hobbys.toString()); 这段代码中，我们写了一个checkName()函数，来校验名称，暂且只是校验不能有数字吧，然后再构造函数里的第一行代码中进行校验，若校验不通过，则抛出异常。这里我传入一个名称Helen666，结果抛出如下异常： Error: 名字 Helen666 不能存在数字 这样就做到了一个基本的封装，实现内部校验。 但是又有个问题，我们还可以这样来定义名称： 123var person1 = new Person(&quot;Helen&quot;,&quot;20&quot;);person1.name = &quot;Helen666&quot;;person1.sayName(); //Helen666 这样名称还是可以修改为不合法的名称，于是我们想到用get方法和set方法来做控制，只能通过set方法来赋值，同时通过set方法进行校验，而通过get方法来获得值。现在的代码修改如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Interfacevar People = new Interface(&quot;People&quot;,[&quot;setName&quot;,&quot;getName&quot;,&quot;setAge&quot;,&quot;getAge&quot;,&quot;addHobby&quot;,&quot;getHobby&quot;,&quot;sayName&quot;,&quot;sayAge&quot;]);var Person = function(name,age)&#123; //implement People this.setName(name); this.setAge(age); this._hobbys = [];&#125;Person.prototype = &#123; //校验函数 checkName:function(name)&#123; re = /\d/; return re.test(name); &#125;, sayName:function()&#123; console.log(this._name); &#125;, sayAge:function()&#123; console.log(this._age); &#125;, addHobby:function(hobbys)&#123; this._hobbys = this._hobbys.concat(hobbys); &#125;, getHobby:function()&#123; return this._hobbys; &#125;, setName:function(name)&#123; if(this.checkName(name))&#123; throw new Error(&quot;名字 &quot;+name+&quot; 不能含有数字&quot;); &#125; this._name = name; &#125;, getName:function()&#123; return this._name; &#125;, setAge:function(age)&#123; this._age = age || &quot;未设置&quot;; &#125;, getAge:function()&#123; return this._age; &#125;&#125;var person1 = new Person(&quot;Helen&quot;,&quot;20&quot;);person1.addHobby([&apos;sing&apos;,&apos;drawing&apos;]);function record(person)&#123; Interface.ensureImplements(person,People); person.sayName(); console.log(person.getHobby().toString());&#125;record(person1); 运行结果： Helen sing,drawing 首先，这段代码我们使用了接口，定义了People接口，而person来实现这个接口，注意注释的内容。 其次，我们使用了get方法和set方法来取值和赋值，我们可以约定程序员只能通过set来赋值，而在set方法里面我们对所赋予的值进行了校验，以确保准确。但是这仅仅是一种约定，程序员依然可以通过person1.name = &quot;123&quot;来赋值，修改内部属性。 为了规范和起到提醒作用，我们把内部属性的命名进行规范，在这些属性前面加上“_”，比如 _name、_age，这样如果程序员要直接修改属性，那么他就必须这样写person1._name = &quot;123&quot;，这明显是一种故意的做法，一般程序员不会这么做，起到规范和提醒的作用。 尽管如此，这种仅仅是用规定进行约束，还是无法阻止通过person1._name进行修改，下面的方法可以做到把内部属性真正做到私有化。 通过闭包进行封装 如果对闭包不太理解，请阅读JavaScript函数表达式以及JavaScript变量和作用域，我们来看一下如何实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Interfacevar People = new Interface(&quot;People&quot;,[&quot;setName&quot;,&quot;getName&quot;,&quot;setAge&quot;,&quot;getAge&quot;,&quot;addHobby&quot;,&quot;getHobby&quot;,&quot;sayName&quot;,&quot;sayAge&quot;]);var Person = function(name,age)&#123; //implement People // 私有变量 var _name,_age,_hobbys = []; this.addHobby = function(hobbys)&#123; _hobbys = _hobbys.concat(hobbys); &#125;, this.getHobby = function()&#123; return _hobbys; &#125;, this.setName = function(name)&#123; if(this.checkName(name))&#123; throw new Error(&quot;名字 &quot;+name+&quot; 不能含有数字&quot;); &#125; _name = name; &#125;, this.getName = function()&#123; return _name; &#125;, this.setAge = function(age)&#123; _age = age || &quot;未设置&quot;; &#125;, this.getAge = function()&#123; return _age; &#125; this.setName(name); this.setAge(age);&#125;Person.prototype = &#123; checkName:function(name)&#123; re = /\d/; return re.test(name); &#125;, sayName:function()&#123; console.log(this.getName()); &#125;, sayAge:function()&#123; console.log(this.getAge()); &#125;&#125;var person1 = new Person(&quot;Helen&quot;,&quot;20&quot;);person1.addHobby([&apos;sing&apos;,&apos;drawing&apos;]);function record(person)&#123; Interface.ensureImplements(person,People); person.sayName(); console.log(person.getHobby().toString());&#125;record(person1); 在构造函数中，属性不使用this，外部也就无法访问到这个属性，而闭包通过作用域链可以访问到这个属性，那么我们就通过闭包设置了为属性赋值的唯一入口，从而起到了严格校验这些属性的作用。 尽管如此，在构造函数中定义方法很多时候是没必要的，因为这样每创建一个实例，就会产生一个方法的副本，这是需要内存支持的，所以在使用的过程中，如果能用上面的基本封装方法，尽量用，除非对于私有属性有非常严格的校验要求才用闭包这种方法。 作者：翁艺逢 Tab Weng 来自：博客园 Tab Weng的博客：http://www.cnblogs.com/hlwyfeng]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ajax那些事]]></title>
    <url>%2F2016%2F10%2F06%2Fajax%2F</url>
    <content type="text"><![CDATA[ajax是一种创建交互式网页应用的网页开发技术。就是在不重新加载页面的情况下，更新部分网页。 ajax原理：ajax就是相当于在用户和服务器之间加了一个中间层，是用户操作与服务器操作相应异步化。并不是所有的用户请求都提交给服务器，像一些数据验证和数据处理等都交给了ajax引擎自己来做，只有确定需要从数据库读取数据的时候，再由ajax引擎代为向服务器提交请求。 ajax核心：通过XMLHttpRequest获取非本页内容。ajax优势： 通过异步处理的模式提升用户体验 优化浏览器与服务器之间的传输，减少不必要数据的往返，减少带宽（单位时间内通过的数据量）占用 ajax引擎在客户端运行，承担一部分本来有服务器承担的任务，从而减少负载 ajax缺点： 不能实时请求和响应服务器数据 不支持浏览器回退功能 不能提交媒体数据，图片和文件 原生写的ajax五部曲，必不能忘记：12345678910111213141516171819function ajax()&#123; // 1.创建异步对象 var ajaxObj = new XMLHttpRequest(); // 2.设置url 方法 ajaxObj.open(&apos;get&apos;,&apos;xxx.php&apos;); // 3.发送请求 ajaxObj.send(); // 4.为状态改变事件 绑定 对应的代码 ajaxObj.onreadystatechange = function () &#123; if (ajaxObj.readyState == 4 &amp;&amp; ajaxObj.status==200) &#123; // 5.在数据回来之后,修改界面的内容 // 创建元素,添加到界面上,或者 其他的操作 console.log(ajaxObj.responseText); &#125; &#125;&#125; 关于readyState共有五个状态0 － （未初始化）已经创建对象，还没有调用send方法 1 － （加载）准备开始发送数据 2 － （加载完成）已发送数据，正在等待响应返回 3 － （交互）正在接受响应，但是接受不完整 4 － （完成）接受响应完毕 （2、3、4都与响应挂钩，开始、过度、完成） 关于status ：200，请求成功其他： 1xx - 信息提示 2xx - 成功 3xx - 重定向 4xx - 客户端错误 作者：Brooke梵 来自：http://www.cnblogs.com/Brookeshan/p/6091620.html]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取当前时间(昨天、今天、明天)]]></title>
    <url>%2F2016%2F10%2F06%2Ftime%2F</url>
    <content type="text"><![CDATA[开发过程中某些前台页面的时间控件我们需要给默认当前时间，jquery可以轻松的帮我们实现，代码如下 12345678910111213141516171819//昨天的时间var day1 = new Date();day1.setTime(day1.getTime()-24*60*60*1000);var s1 = day1.getFullYear()+&quot;-&quot; + (day1.getMonth()+1) + &quot;-&quot; + day1.getDate();//今天的时间var day2 = new Date();day2.setTime(day2.getTime());var s2 = day2.getFullYear()+&quot;-&quot; + (day2.getMonth()+1) + &quot;-&quot; + day2.getDate();//明天的时间var day3 = new Date();day3.setTime(day3.getTime()+24*60*60*1000);var s3 = day3.getFullYear()+&quot;-&quot; + (day3.getMonth()+1) + &quot;-&quot; + day3.getDate();//拼接时间function show()&#123; var str = &quot;&quot; + s1 + &quot;至&quot; + s2; return str;&#125;//赋值doubleDate$(&apos;#dateS&apos;).val(show()); 下面是具体到时分秒的获取方法 123456789101112131415161718192021222324252627function writeCurrentDate() &#123; var now = new Date(); var year = now.getFullYear(); //得到年份 var month = now.getMonth();//得到月份 var date = now.getDate();//得到日期 var day = now.getDay();//得到周几 var hour = now.getHours();//得到小时 var minu = now.getMinutes();//得到分钟 var sec = now.getSeconds();//得到秒 var MS = now.getMilliseconds();//获取毫秒 var week; month = month + 1; if (month &lt; 10) month = &quot;0&quot; + month; if (date &lt; 10) date = &quot;0&quot; + date; if (hour &lt; 10) hour = &quot;0&quot; + hour; if (minu &lt; 10) minu = &quot;0&quot; + minu; if (sec &lt; 10) sec = &quot;0&quot; + sec; if （MS &lt; 100）MS = &quot;0&quot; + MS; var arr_week = new Array(&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;); week = arr_week[day]; var time = &quot;&quot;; time = year + &quot;年&quot; + month + &quot;月&quot; + date + &quot;日&quot; + &quot; &quot; + hour + &quot;:&quot; + minu + &quot;:&quot; + sec + &quot; &quot; + week; //当前日期赋值给当前日期输入框中（jQuery easyUI） $(&quot;#currentDate&quot;).html(time); //设置得到当前日期的函数的执行间隔时间，每1000毫秒刷新一次。 var timer = setTimeout(&quot;writeCurrentDate()&quot;, 1000);&#125; 作者：码出一片天 来自：http://www.cnblogs.com/sxxjyj/p/6093326.html]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS Float 以及相关布局模式]]></title>
    <url>%2F2016%2F10%2F06%2Ffloat%2F</url>
    <content type="text"><![CDATA[float 取值 属性 值 描述 left 向左浮动 right 向右浮动 none 默认值 inherit 继承 看一个例子: 红色线框代表父元素 脱离文档流，其实也没有完全脱离，会被父元素的边界挡住。 float的元素在同一文档流看一个例子: 红线框代表父元素 三个子元素『向左浮动』之后， 父元素就没有内容了，所以父元素没有高度了。 float元素半脱离文档流对元素，脱离文档流；对内容，在文档流。元素时会重叠，但是内容不会重叠。 举个例子： 12345678910111213141516171819202122body&#123; width: 300px;padding: 5px;line-height: 1.6; border: 1px dashed blue;&#125;.sample&#123; height: 100px;margin-right: 5px; padding: 0 5px; line-height: 100px;background-color: pink;&#125;.sb&#123; outline: 1px dashed red;&#125;.sample&#123; float: left;&#125;&lt;div class=&quot;sample&quot;&gt;float : left &lt;/div&gt;&lt;div class=&quot;sb&quot;&gt;A float is a box that is shifted to the left or right on the current line .the most interesting characteristic of a float (o &quot;floated&quot; o &quot;floating&quot; box)is that content may flow along its side (or be prohibited from doing so by the &apos;clear&apos;property).&lt;/div&gt; 12345678910111213141516171819202122body&#123; width: 400px;line-height: 1.6;&#125;.sample&#123; width: 100px;line-height: 100px; margin: 3px;text-align: center; background-color: pink;&#125;.sb&#123; margin: 10px auto; padding: 5px; border: 1px dashed #0f00fa;&#125;.sample&#123; float: left;&#125;&lt;div class=&quot;sb&quot;&gt; &lt;div class=&quot;sample&quot;&gt;float: left;&lt;/div&gt; 第十二届ChinaJoy 动漫游戏展7月31号在上海新国际博览中心开幕，导出是站台表演的帅哥美女。&lt;/div&gt;&lt;div class=&quot;sb&quot;&gt;有些游戏商为了吸引人气，还请来了著名的演员、模特前来助阵。以下是一批漂亮的Show Girl现场照片。&lt;/div&gt; 通常我们并不想要这个结果，而是粉色div 只被第一个文字块环绕。 需要使用clear属性 clear要理解clear，首先要知道 div是块级元素，在页面中独占一行，自上而下排列，也就是传说中的流 属性 值 描述 clear both 包含left和right left 左侧不允许其他浮动元素 right 右侧不允许其他浮动元素 none 默认值 inherit ①应用于后续元素, 来清除浮动对后续的影响。 ②应用于块级元素 使用方式：增加一个空白元素(用得较少) clearfix，这是一般通用方案。实际上是用一个不可用的点号，来清除浮动。 举个例子： 123456789101112131415161718192021222324252627282930313233343536body&#123; width: 400px;line-height: 1.6;&#125;.sample&#123; width: 100px;line-height: 100px; margin: 3px;text-align: center; background-color: pink;&#125;.sb&#123; margin: 10px auto; padding: 5px; border: 1px dashed #0f00fa;&#125;.sample&#123; float: left;&#125;.clearfix:after&#123; content: &apos;.&apos;; /* 在clearfix后面加入一个 . */ display: block; /* 设置 . 块级元素 */ clear: both; /* 清除浮动效果 */ /*隐藏那个 . */ height: 0; overflow: hidden; visibility: hidden;&#125;/* .clearfix&#123; zoom: 1; 由于在IE 低版本中，不支持after属性，所以需要增加zoom属性 &#125; */&lt;div class=&quot;sb clearfix&quot;&gt; &lt;div class=&quot;sample&quot;&gt;float: left;&lt;/div&gt; 第十二届ChinaJoy 动漫游戏展7月31号在上海新国际博览中心开幕，导出是站台表演的帅哥美女。&lt;/div&gt;&lt;div class=&quot;sb&quot;&gt; 有些游戏商为了吸引人气，还请来了著名的演员、模特前来助阵。以下是一批漂亮的Show Girl现场照片。&lt;/div&gt; 作者：刘江龙 来自：http://www.cnblogs.com/qq-757617012/p/6018579.html]]></content>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>float</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[既然写CSS很容易，那为什么大家还是把CSS写的那么烂呢]]></title>
    <url>%2F2016%2F10%2F04%2Fcss-easy%2F</url>
    <content type="text"><![CDATA[在你开始阅读这篇文章之前，一定要做好心理准备。因为我写的 90％ 都是在发牢骚，只有最后大概 10% 介绍 CSS 技巧之最佳实践。提前给你们打好预防针啦。 前端工程师在职业发展中可能会遇到以下困境： 某个阶段，感觉(自己所做的)工作没有任何难度 为团队创造的价值越来越低啦 自己做的事情，大家都能做 同意的请举手。如果你确实是这样，（恭喜你）说明你是多数派。 而且说句实在话，CSS 确实很简单。另外我可以保证，就算是傻子也能写出下面的代码： p { color: red; } 那么你还有什么好抱怨的？堆纯 CSS 代码，不需要任何技巧。而且只给单个元素添加全局样式，而不用考虑其他 CSS，当然是非常简单的。 那么CSS到底难在哪儿？ 后端开发工程师：“虽然我已经完成新功能的开发，但是我弄乱了前端，不过你放心，我已经修好绝大部分，所以你前端只需要对细节进行微调，时间应该不会超过 30 分钟” 于是我打开HTML文件，(吃惊地)发现到处都是弃用的HTML标签，而且丝毫没有考虑过响应式设计。深呼吸，(暗示自己)，他们写的CSS肯定会稍微好点。然而在我打开CSS文件之后，发现(同样)到处都是类似固定(fixed)定位、清除左浮动、右浮动以及!important的代码，于是我慢慢的把鼠标绕在脖子上。（别拦我，让我死） （安慰自己），也许他们写出的代码不会一直这么糟糕，但是（在现实中）我几乎没见过后端工程师写出能用的前端代码的。也还好啦，写前端代码本来就不是后端工程师的职责所在。但是请后端工程师不要随便写一堆前端代码，然后指望前端工程师帮你擦屁股。 所以好的CSS长啥样？ (项目的)组织结构。尤其是当你做过大型项目，就会发现项目的组织结构真的很重要。举个正面例子——Steven Bradley 写的利于维护代码的目录结构，这篇文章是为 SCSS 项目写的，不过也适用于普通的 CSS 项目。它重点强调如何将 CSS 文件模块化，形成便于维护的文件。 规范。这可能是我每天所遇到的最大问题。不幸的是，大部分工程师对CSS规范的理解一知半解，正是因为这样，才导致糟糕的 CSS 代码（如 !important）烂大街。那我们该如何避免呢？下面列出了很多值得参考的命名约定，它们旨在减少写死的（非常依赖文档结构的） CSS 选择器。假设你对此不感冒，我还是要劝你如无必要，避免使用超过 3 层的 CSS 类/元素选择器。 命名约定。恕我直言，对于任何一个大型的 CSS 项目来说，命名约定是标配。没有命名约定，CSS 就会变得既难维护又不可靠。命名约定可以让我们轻松地重用项目中的 CSS，如有必要，还能帮我们剔除项目中多余的 CSS。这里仅列举几种比较流行的命名约定，如：BEM，OOCSS，SMACSS以及我自己写的hiccup。 测试。在这一点上，绝大多数其它工程师可能都没发现当后端工程师有多爽。 因为后端工程师的开发工作只需要让一个环境（网站所在的服务器）正常即可。你知道作为前端工程师最痛苦的事情是什么吗？5 个以上的浏览器以及上千种移动设备……好的前端测试工作其实是个苦差，且耗时很长。我见过很多项目延期，就因为没有把前端测试考虑进去，而通常前端测试花费的时间会超出常人预期。 所以如何扭转这种对CSS的天真看法？ 在以后工作中，再也不能让后端工程师们抱有侥幸心理。作为前端工程师，我们不会随便把一堆无响应式的 CSS 代码丢给后端工程师，然后撒手不管。所以凭什么他们就能写无用的烂代码，然后在他们的 CSS 代码失效时让我们去打补丁？我不是说要让后端工程师好好写 CSS 代码，而是我们应该告诉后端工程师，如果觉得写 CSS 很难的话，就不要写。别让其他工程师觉得前端很简单，前端才不简单呢，我们前端工程师跟其他人一样努力地工作，别让他们看走眼。 作者：Hacker Noon 原文链接：https://hackernoon.com/if-css-is-so-easy-why-does-everyone-suck-e4442cc9428a#.bq9c1sev1 来自：http://www.zcfy.cc/article/if-css-is-so-easy-why-does-everyone-suck-hacker-noon-1683.html]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe关于滚动条的去除和保留]]></title>
    <url>%2F2016%2F10%2F03%2Fiframe%2F</url>
    <content type="text"><![CDATA[iframe嵌入页面后，我们有时需要调整滚动条，例如，去掉全部的滚动条，去掉右边的滚动条且保留底下的滚动条，去掉底下的滚动条且保留右边的滚动条。那么我们应该怎么做呢？ 一：去掉全部的滚动条第一个方法： iframe 有一个scrolling属性，它有 auto , yes , no 这三个值。scrolling : auto —–在需要的时候滚动条出现 scrolling : yes ——始终显示滚动条 scrolling : no ——-始终隐藏滚动条 当设置 scrolling : no 时，全部的滚动条就没有了。 第二个方法：我发现除了 scrolling 可以去掉全部的滚动条外，还有另一个方法，在嵌入的页面里设置 body{overflow：hidden}，这样也可以将滚动条去掉，而且这也是当我们只想去掉某一个滚动条所使用的属性。二：去掉右边的滚动条且保留底下的滚动条如果只想保留底下的滚动条，那么可以在嵌入的页面里设置 body{overflow-x：auto ; overflow-y：hidden;} 三：去掉底下的滚动条且保留右边的滚动条在嵌入的页面里设置 body{overflow-x：hidden；overflow-y：auto；} 我们已经知道了这两个属性都可以设置滚动条的显示和隐藏，那么当两个同时设置时，会出现哪个效果呢？ 通过检测，我发现当scrolling = “ auto “或者“ yes “时，如果设置了body，那么就会使用body里的设置；当scrolling = “ no “时，不管body设置了什么，都会使用scrolling的设置，即全部的滚动条都被去掉了。 作者：yezi-dream 来自：http://www.cnblogs.com/yezi-dream/p/6070616.html]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http响应状态码大全]]></title>
    <url>%2F2016%2F09%2F30%2Fstate%2F</url>
    <content type="text"><![CDATA[http状态返回代码 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。 http状态返回代码:代码 说明 100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 http状态返回代码 2xx（成功）表示成功处理了请求的状态代码。 http状态返回代码:代码 说明 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。 http状态返回代码 3xx（重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 http状态返回代码:代码 说明 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 http状态返回代码 4xx（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 http状态返回代码:代码 说明 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 http状态返回代码 5xx（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 http状态返回代码:代码 说明 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 一些常见的http状态返回代码为：200 - 服务器成功返回网页 404 - 请求的网页不存在 503 - 服务不可用 原文：http://blog.sina.com.cn/s/blog_4ae187490100x9u7.html]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5标签]]></title>
    <url>%2F2016%2F09%2F30%2Fhtml-label%2F</url>
    <content type="text"><![CDATA[可以进行省略的标签不允许写结束标记的标签：area(定义图像映射中的区域)、base(为页面上的所有链接规定默认地址或默认目标)、br、col(为表格中一个或多个列定义属性值)、embed(定义嵌入的内容，比如插件–5)、hr、img、input、keygen、link、meta、param、source、track、wbr 可以省略结束标记的标签：li、dt、dd、p、rt、optgroup、option、colgroup、thread、tbody、tr、td、th 可以完全省略的标签：html、head、body、colgroup、tbody 新增的标签section:页面中的一个内容区块，入章节、页面、页脚或页面的其他部分、可以和h1、h2…等标签结合起来使用，表示文档结构。 article:表示页面中一块与上下文不相干的独立内容，比如一篇文章。 aside:定义 article 以外的内容。aside 的内容应该与 article 的内容相关。 header:页面中的内容区块或整个页面的标题。 footer:页面中的内容区块或整个页面的脚注。 hgroup:页面中的内容区块或整个页面的标题进行组合。 nav:导航链接的部分。 figure:规定独立的流内容（图像、图表、照片、代码等等，内容应该与主内容相关，但如果被删除，则不应对文档流产生影响）。 video:视频。exp:视频 audio:音频。 embed:用来嵌入内容（包括各种媒体）。 mark:变颜色，关注。 progress:进度条。exp: time:定义日期或时间，或者两者。这个标记是给收索引擎用的，引擎会根据这个标注知道这块表示一个时间。有个属性为pubdate，当引擎读到时就知道这块中的datatime中的值就是这篇文章的发布时间，而在这时间中有两个特殊的字符T和Z。T表示日期和时间的分隔符，Z表示时间的标准格式。exp: datalist:定义选项列表。与 input 元素配合使用该元素，来定义 input 可能的值。exp: output:exp:0100+= 全局属性data-type:自定义属性。 hidden:隐藏，单标签。 spellcheck:对输入内容进行语法纠错。exp: tabindex:tab键顺序。 contenteditable:对内容进行修改。exp: 让整个文本都可编辑：&lt;script&gt;window.document.designMode=&quot;off&quot;;&lt;/script&gt;//off关闭,on:可编辑 作者：sctnl 来自：http://www.cnblogs.com/sctnl/p/6084726.html]]></content>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么你有时看起来很傻]]></title>
    <url>%2F2016%2F09%2F28%2Fsilly%2F</url>
    <content type="text"><![CDATA[在生活和工作中，往往会因为一些事情的处理不当而让周围的人产生一种 “这个人好傻”的想法，这种想法可能来自于各个层面，如：经验、阅历、性格、素质等。由于每个人成长环境不同，性格方面自然存在着差异，阅历随着每个人的成长都会不同程度的增加，而当下我们最容易改变的就是个人素质和能力。 在企业中员工的素质与能力是衡量优秀员工的重要标准，而个人素质又可以分为以下11个方面：懒惰（勤奋）、懦弱（勇敢）、冒失（镇定）、马虎（细致）、逃避（担当）、渎职（敬业）、无序（规划）、放纵（自律）、自闭（互动）、愚钝（灵性）、奸猾（忠诚）。 那么就让我们从这11个素质中看看是否有让你看起来很傻的原因。 懒惰茅盾曾经说过：“天分高的人如果懒惰成性，亦即不自努力以发展他的才能，则其成就也不会很大，有时反会不如天分比他低些的人。”人是极容易产生懒惰心理的，这是本性之一。 我们在工作中一定会遇到如下情况，明明是自己定下的计划却无法长期坚持，把不是必须做的事抛到九霄云外，应该做的事，什么时候催什么时候做，这就是懒惰心理。而这样的你往往不知道，那些克服惰性的人正一步步的在完成自己的计划，提高自己的能力。 所以那些常常抱怨为什么自己比同期的员工都聪明，却得不到提拔重用的人，应该想一想是不是自身的惰性在作祟。 懦弱懦弱的表现大多来自内心的自我否定，在人际交往中很在意别人对自己的看法，他人即使稍微表示一下不悦都令你感到紧张，正是因为这样，常常不能表达自己内心的真实想法，委曲求全，在你看来的不好意思，在别人眼里往往就是好欺负的表现。 所以，应该调整这种心态，让自己充满自信，当别人触及到你的利益或是底线时，抛开所谓的“人情、看法”，大声说出你的感受。在遇到困难时，拿出勇气去面对，去克服。 所以那些常常因懦弱而不能被认可的人，要明白改变自身的懦弱的同时，他人对你的看法也许已经不一样了。 冒失诗人席勒曾经说过一句话：“只有绝望的赌鬼才肯把全部所有作孤注的一掷。一个商人如果把他的全部财产装在一只船上，人家就管他叫冒失鬼。” 举一个在工作中的例子：某项目人员，在进行数据库操作时，没有对相关数据进行备份处理，操作失误将数据库中的数据都误删了，这对项目的进度造成的极大的影响，而这名员工从此就被扣上了：做事没有分寸考虑不够周全的帽子，恐怕再难受任。 那些冒失的人在遇到事情的时候，不妨在心中默念10个数，冷静下来再做决定；遇到棘手的事情时，从多个方面来考虑，谋定而后动。 马虎不知道读者中有木有人曾经被叫做“马虎大王”？其实许多人身上都存在着马虎的现象，问题看似很小，但造成的损失可不一定小。 想要改变马虎应注意以下几个方面： 了解自己马虎的原因，找出症结所在。 养成认真检查的习惯，集中精神做检查工作。 给自己定个惩罚，马虎一次，惩罚一次。 记录马虎错误，时常翻看谨记。 逃避没事别找事，有事别怕事。使我们逃避的，是未知；使我们恐惧的，是逃避。 我们身边总有这样一些人：考试周，看着书本太厚太难，准备时间太短太急，干脆自暴自弃：“我不复习了，裸考算了。” 招聘季，师兄师姐说找好工作要正装、化妆和自我包装，“找工作也太麻烦了吧，我晚点再找。” 工作时，上级指派给新任务，要求三天内按时高质量完成，“这根本不可能做到，我能不能不做了？” 碰到稍微不熟悉的困难就逃避拖延，以上现象被诊断为逃避型人格综合症。其实，大部分人，遇到陌生事物的第一反应，就是逃避。但是逃避往往可以暂时缓解压力，但却会导致更加严重的后果。 如果不想被人一直贴着逃避的标签，那不如试着变被动面对为主动选择，写下所有困难，逐一攻克，攻克不了就去求助，顾虑太多时干脆抛开顾虑，冲了再说。 渎职渎职是指专业服务者（例如医药人员）或国家机关工作人员在履行职责或者行使职权过程中，玩忽职守、滥用职权或者徇私舞弊，导致伤害或损失，致使国家财产、国家和人民利益遭受重大损失的行为。渎职中渎的字面意思是“轻慢，对人不恭敬”。 与其说是渎职，更准确的来说应该是失职。失职是指工作人员对本职工作不认真负责，未依照规定履行自己的职务，致使单位或服务对象造成损失的行为。作为一名职场上打拼的员工，失职就是对自己的工作没有认真的态度，对自己的工作都不放在心上的员工，公司又怎么会花费大精力去培养呢。 无序成功始于计划，没有计划就是在计划失败。当你养成制定计划的习惯之后，从前成就平平的你，一定会取得意想不到的成绩。 要制定计划，先明确想要达到的目标，然后坚持按照计划实现这个目标。第一，合理安排计划，合理安排时长：每小时，每日，每月。第二，有组织的工作及持续的热情是力量的源泉；第三，要有把计划进行到底的决心。 想改变自己无序的现状，那么从今天开始就制定目标，规划未来的航向。正如罗伯特.F.梅杰说：“如果你没有明确的目的地，你很可能走到不想去的地方去。” 放纵古儒讲，一个人一生要先从“修身”做起，然后才能“齐家，治国，平天下”。所谓“修身”，就是自律，明白做人的道理，做人的规矩，然后，才可以进入社会。 有人会认为自己很年轻，有大把的时间可以去放纵、挥霍，那么这种想法很有可能会对他今后的生活、工作产生不利，放纵的习惯一旦形成，就很难改掉，当面对一些事情的时候，往往会不自律，甚至产生不顾后果直接放弃的想法。有的时候，别人会感觉这种人活得很洒脱，但是在职场中，这种人往往是不被看好的。总之一句话，要做天下事，先从自身起。 自闭提到自闭，第一反应就是不喜欢与人接触、不善于与人沟通，但是在工作和生活中，沟通是必不可少的。 对一个组织而言，良好的沟通可以使员工认清形势，使决策更加合理、有效。主管可以通过沟通，引导属员更好地工作；属员可以通过沟通，更好地理解、执行领导的意图和决策；同事之间可以通过沟通，更加精诚团结密切合作。在一个组织里，所有的决策和共识，都是通过沟通来达成的。 如果你是一个不擅长沟通的人，那么从现在开始，你就要学着多与人沟通，这样不仅可以扩大你的交际圈，而且可以使你避免工作上不必要的误解及麻烦。 愚钝有人天生聪明，有人天生愚钝，但这并不能成为成功的阻碍，就像儿时听过的龟兔赛跑的故事一样，聪明的人好比是兔子，一开始干劲十足，进步飞快，而愚钝的人好比是老龟，脚踏实地，每天都有一点小小的进步，持之以恒。 聪明的人并不会有多大的成就，取得成功的往往是那些既聪明还持之以恒的人，他们没有浪费自己的聪明才智，并学会了老龟的持之以恒，这样的人才是精英、骨干，而资质平庸但兢兢业业努力做到每天进步一点点的人，往往最后也能取得不错的成功。 总之，不论天生聪颖也好，资质平庸也罢，最后靠的还是自己的那一份努力。 奸猾奸猾指诡诈狡猾，真正狡猾的人是平时看似很真诚的人，圆滑却又不中立。善于用语言去瓦解他人，却又不留痕迹；看似为他人着想，实则在达到自己的目的，懂得用小代价换取大成功。 想必大家都很讨厌这种人，而这种人无论做的多完美，也总有暴漏的一天，最后只是搬起石头砸了自己的脚。所以一定要衡量自己的内心，做一个真诚的人才能得到周围人的认可。 以上这11种个人素质都会对我们的生活和工作产生重大的影响，只有在不断的历练中提高个人素质，升华品德性格，未来成长的道路才会更加的宽广，人生才不会留下缺憾。 来自：http://www.cnblogs.com/agileai/p/6078666.html]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript函数表达式]]></title>
    <url>%2F2016%2F09%2F27%2Ffunction%2F</url>
    <content type="text"><![CDATA[函数表达式的基本语法形式var functionName = function(arguments){ //函数体 } 递归建议 我们通过例子来一步步说明，递归的最佳实现方式。下面是普通递归调用的例子： 12345678910// 阶乘的递归函数var factorial = function(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else &#123; return num * factorial(num-1); &#125;&#125;console.log(factorial(3)); //6 我们来看一下这种情况： 123456// 赋给一个变量var anotherFactorial = factorial;factorial = null;// 调用递归函数console.log(anotherFactorial(3)); 运行结果： TypeError: factorial is not a function 这里提示错误，说factorial不是一个函数，因为我们已经把factorial设置为null，而在执行anotherFactorial(3)时，是通过factorial(num-1)来递归调用的，所以就报错，因为已经把factorial设置为null。 解决的策略就是使递归调用的函数内部不要出现外部定义的函数名。 我们可以通过命名表达式来实现（注意括号的使用）： 1234567891011121314var factorial = (function f(num)&#123; if(num &lt;= 1)&#123; return num; &#125;else &#123; return num * f(num-1); &#125;&#125;);console.log(factorial(3)); //6var anotherFactorial = factorial;factorial = null;console.log(anotherFactorial(3)); //6 理解匿名函数 匿名函数：function后面没有跟着函数名的函数 123var functionName = function(arguments)&#123; //函数体&#125; 当然匿名函数也可以不要赋值给变量：123(function(num)&#123; console.log(num+1);&#125;)(3); 运行结果： 4 匿名函数也可以作为函数返回：123456function person()&#123; return function()&#123; console.log(&quot;TabWeng&quot;); &#125;&#125;person()(); 运行结果： TabWeng 对于person()()，有些人不太理解，其实不难理解，这里解释一下： 首先来看一下person()，我们是不是得到一个返回的匿名函数function(){console.log(“TabWeng”);}，既然我们得到了一个函数，对于函数的调用，是不是给它的尾部加一个括号就可以了，所以就写成person()()。 理解闭包 闭包：有权访问另一个函数作用域的函数 匿名函数是function后面没有跟着函数名的函数，和闭包的定义不同，尽管这两个称呼经常说的是同一个函数，但是根据功能的不同，应该加以区分。 如果你理解作用域链，那么闭包就非常好理解。通过闭包的这种特性，我们可以来实现JavaScript的很多模式，更加灵活的运用JavaScript。 如果要访问一个函数的作用域，我们可以在函数里面创建一个闭包，对于闭包而言，被访问的函数处在闭包作用域链的第二层（从前端到终端的顺序），而作用域链的指针指向的是整个活动对象。 有一个典型的例子不得不讲： 123456789101112131415function printNum()&#123; var nums = []; for(var i = 0; i &lt; 3; i++)&#123; nums[i] = function()&#123; return i; &#125; &#125; for(var j = 0; j &lt; nums.length; j++)&#123; console.log(nums[j]()); &#125;&#125;printNum(); 运行结果： 3 3 3 为什么会得到这样的结果，存在两个疑问： 为什么结果是3？不应该是2吗？ 为什么结果都是3？我们先来分析一下出现的原因： 首先针对问题2，在闭包里面有return i;，而在闭包中，i是没有定义的，根据作用域链，会向上一层作用域链寻找i，在上一层中我们发现了i，我们是通过寻找上一层的活动对象来找到i的，既然是活动对象，里面的数值就是最终的值，所有此时的i已经是最终的值3了，我获得的i就是最终的值3。因此打印出来每个结果都是3。 知道了问题2出现的原因，那么问题1也就是自然明了，在for循环中，i加到等于3，通过i&lt;3,使i没有进入for循环的里面，尽管 i==3 没有进入for循环，但是闭包在获取i的时候，获取的就是i的最后一个值3。 通过立即执行函数来解决这个问题： 123456789101112131415function printNum()&#123; var nums = []; for(var i = 0; i &lt; 3; i++)&#123; nums[i] = function(num)&#123; return num; &#125;(i); &#125; for(var j = 0; j &lt; nums.length; j++)&#123; console.log(nums[j]); &#125;&#125;printNum(); 运行结果： 0 1 2 性能优化 使用闭包时，因为闭包的作用域链会引用活动对象，使这个活动对象无法被回收（内存），而如果这个引用一直存在，那么内存将一直无法得到释放。通常的解决方法是解除这个引用。（解除引用的方法很多，主要是要有这个性能优化的思想，知道存在的问题）。 闭包的运用 (function(){ //私有作用域 })(); 看这块代码，之所以称为私有，通过作用域链我们可以知道，外部不能访问里面。 而通过闭包可以实现提供公有方法而使外部能对私有变量进行访问。 1234567891011121314function Person(name)&#123; var name = name; var sayName = function()&#123; console.log(name); &#125;; this.publicSayName = function()&#123; console.log(&quot;我访问了name这个属性了：&quot;+name); sayName(); &#125;;&#125;var p1 = new Person(&quot;TabWeng&quot;);p1.publicSayName(); 运行结果： 我访问了name这个属性了：TabWeng TabWeng 这块代码也可以这样写： 1234567891011121314function Person(name)&#123; var name = name; var sayName = function()&#123; console.log(name); &#125;; return function()&#123; console.log(&quot;我访问了name这个属性了：&quot;+name); sayName(); &#125;;&#125;var p1 = new Person(&quot;TabWeng&quot;);p1(); 运行结果： 我访问了name这个属性了：TabWeng TabWeng 通过返回的匿名函数获得私有变量。 当然，也可以这样写： 12345678910111213141516171819function Person(name)&#123; var name = name; var sayName = function()&#123; console.log(name); &#125;; return &#123; printString:&quot;我访问了name这个属性了：&quot;+name, sayName:sayName, publicMethod:function()&#123; sayName(); &#125; &#125;;&#125;var p1 = new Person(&quot;TabWeng&quot;);console.log(p1.printString);p1.sayName();p1.publicMethod(); 运行结果： 我访问了name这个属性了：TabWeng TabWeng TabWeng 这就是模块模式，返回的是一个对象，尽管是对象字面量的形式，也可以得到私有变量。 作者：翁艺逢 Tab Weng 来自：http://www.cnblogs.com/hlwyfeng/p/6082210.html]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的event对象]]></title>
    <url>%2F2016%2F09%2F27%2Fevent%2F</url>
    <content type="text"><![CDATA[Event属性和方法： type：事件的类型，如onlick中的click； srcElement/target：事件源，就是发生事件的元素； button：声明被按下的鼠标键，整数，1代表左键，2代表右键，4代表中键，如果按下多个键，酒把这些值加起来，所以3就代表左右键同时按下；（firefox中 0代表左键，1代表中间键，2代表右键） clientX/clientY：事件发生的时候，鼠标相对于浏览器窗口可视文档区域的左上角的位置；(在DOM标准中，这两个属性值都不考虑文档的滚动情况，也就是说，无论文档滚动到哪里，只要事件发生在窗口左上角，clientX和clientY都是 0，所以在IE中，要想得到事件发生的坐标相对于文档开头的位置，要加上document.body.scrollLeft和 document.body.scrollTop) offsetX,offsetY/layerX,layerY：事件发生的时候，鼠标相对于源元素左上角的位置； x,y/pageX,pageY：检索相对于父要素鼠标水平坐标的整数； altKey,ctrlKey,shiftKey等：返回一个布尔值； keyCode：返回keydown何keyup事件发生的时候按键的代码，以及keypress 事件的Unicode字符；(firefox2不支持 event.keycode，可以用 event.which替代 ) fromElement,toElement：前者是指代mouseover事件中鼠标移动过的文档元素，后者指代mouseout事件中鼠标移动到的文档元素； cancelBubble：一个布尔属性，把它设置为true的时候，将停止事件进一步起泡到包容层次的元素；(e.cancelBubble = true; 相当于 e.stopPropagation();) returnValue：一个布尔属性，设置为false的时候可以组织浏览器执行默认的事件动作；(e.returnValue = false; 相当于 e.preventDefault();) attachEvent(),detachEvent()/addEventListener(),removeEventListener：为制定 DOM对象事件类型注册多个事件处理函数的方法，它们有两个参数，第一个是事件类型，第二个是事件处理函数。在attachEvent()事件执行的时候，this关键字指向的是window对象，而不是发生事件的那个元素； screenX、screenY：鼠标指针相对于显示器左上角的位置，如果你想打开新的窗口，这两个属性很重要； 一些说明： event代表事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等； event对象只在事件发生的过程中才有效。firefox里的event跟IE里的不同，IE里的是全局变量，随时可用；firefox里的要用参数引导才能用，是运行时的临时变量。在IE/Opera中是window.event，在Firefox中是event；而事件的对象，在IE中是 window.event.srcElement，在Firefox中是event.target，Opera中两者都可用。 下面两句效果相同var evt = (evt) ? evt : ((window.event) ? window.event : null);var evt = evt || window.event; // firefox下window.event为null, IE下event为null IE中事件的起泡IE中事件可以沿着包容层次一点点起泡到上层，也就是说，下层的DOM节点定义的事件处理函数，到了上层的节点如果还有和下层相同事件类型的事件处理函数，那么上层的事件处理函数也会执行。例如， div 标签包含了 a ，如果这两个标签都有onclick事件的处理函数，那么执行的情况就是先执行标签 a 的onclick事件处理函数，再执行 div 的事件处理函数。如果希望的事件处理函数执行完毕之后，不希望执行上层的 div 的onclick的事件处理函数了，那么就把cancelBubble设置为true即可。 js event.keyCode对应的键码：keycode 8 = BackSpace BackSpace keycode 9 = Tab Tab keycode 12 = Clear keycode 13 = Enter keycode 16 = Shift_L keycode 17 = Control_L keycode 18 = Alt_L keycode 19 = Pause keycode 20 = Caps_Lock keycode 27 = Escape Escape keycode 32 = space space keycode 33 = Prior keycode 34 = Next keycode 35 = End keycode 36 = Home keycode 37 = Left keycode 38 = Up keycode 39 = Right keycode 40 = Down keycode 41 = Select keycode 42 = Print keycode 43 = Execute keycode 45 = Insert keycode 46 = Delete keycode 47 = Help keycode 48 = 0 equal braceright keycode 49 = 1 exclam onesuperior keycode 50 = 2 quotedbl twosuperior keycode 51 = 3 section threesuperior keycode 52 = 4 dollar keycode 53 = 5 percent keycode 54 = 6 ampersand keycode 55 = 7 slash braceleft keycode 56 = 8 parenleft bracketleft keycode 57 = 9 parenright bracketright keycode 65 = a A keycode 66 = b B keycode 67 = c C keycode 68 = d D keycode 69 = e E EuroSign keycode 70 = f F keycode 71 = g G keycode 72 = h H keycode 73 = i I keycode 74 = j J keycode 75 = k K keycode 76 = l L keycode 77 = m M mu keycode 78 = n N keycode 79 = o O keycode 80 = p P keycode 81 = q Q at keycode 82 = r R keycode 83 = s S keycode 84 = t T keycode 85 = u U keycode 86 = v V keycode 87 = w W keycode 88 = x X keycode 89 = y Y keycode 90 = z Z keycode 96 = KP_0 KP_0 keycode 97 = KP_1 KP_1 keycode 98 = KP_2 KP_2 keycode 99 = KP_3 KP_3 keycode 100 = KP_4 KP_4 keycode 101 = KP_5 KP_5 keycode 102 = KP_6 KP_6 keycode 103 = KP_7 KP_7 keycode 104 = KP_8 KP_8 keycode 105 = KP_9 KP_9 keycode 106 = KP_Multiply KP_Multiply keycode 107 = KP_Add KP_Add keycode 108 = KP_Separator KP_Separator keycode 109 = KP_Subtract KP_Subtract keycode 110 = KP_Decimal KP_Decimal keycode 111 = KP_Divide KP_Divide keycode 112 = F1 keycode 113 = F2 keycode 114 = F3 keycode 115 = F4 keycode 116 = F5 keycode 117 = F6 keycode 118 = F7 keycode 119 = F8 keycode 120 = F9 keycode 121 = F10 keycode 122 = F11 keycode 123 = F12 keycode 124 = F13 keycode 125 = F14 keycode 126 = F15 keycode 127 = F16 keycode 128 = F17 keycode 129 = F18 keycode 130 = F19 keycode 131 = F20 keycode 132 = F21 keycode 133 = F22 keycode 134 = F23 keycode 135 = F24 keycode 136 = Num_Lock keycode 137 = Scroll_Lock keycode 187 = acute grave keycode 188 = comma semicolon keycode 189 = minus underscore keycode 190 = period colon keycode 192 = numbersign apostrophe keycode 210 = plusminus hyphen macron keycode 211 = keycode 212 = copyright registered keycode 213 = guillemotleft guillemotright keycode 214 = masculine ordfeminine keycode 215 = ae AE keycode 216 = cent yen keycode 217 = questiondown exclamdown keycode 218 = onequarter onehalf threequarters keycode 220 = less greater bar keycode 221 = plus asterisk asciitilde keycode 227 = multiply division keycode 228 = acircumflex Acircumflex keycode 229 = ecircumflex Ecircumflex keycode 230 = icircumflex Icircumflex keycode 231 = ocircumflex Ocircumflex keycode 232 = ucircumflex Ucircumflex keycode 233 = ntilde Ntilde keycode 234 = yacute Yacute keycode 235 = oslash Ooblique keycode 236 = aring Aring keycode 237 = ccedilla Ccedilla keycode 238 = thorn THORN keycode 239 = eth ETH keycode 240 = diaeresis cedilla currency keycode 241 = agrave Agrave atilde Atilde keycode 242 = egrave Egrave keycode 243 = igrave Igrave keycode 244 = ograve Ograve otilde Otilde keycode 245 = ugrave Ugrave keycode 246 = adiaeresis Adiaeresis keycode 247 = ediaeresis Ediaeresis keycode 248 = idiaeresis Idiaeresis keycode 249 = odiaeresis Odiaeresis keycode 250 = udiaeresis Udiaeresis keycode 251 = ssharp question backslash keycode 252 = asciicircum degree keycode 253 = 3 sterling keycode 254 = Mode_switch 键值对应表A 0X65 U 0X85 B 0X66 V 0X86 C 0X67 W 0X87 D 0X68 X 0X88 E 0X69 Y 0X89 F 0X70 Z 0X90 G 0X71 0 0X48 H 0X72 1 0X49 I 0X73 2 0X50 J 0X74 3 0X51 K 0X75 4 0X52 L 0X76 5 0X53 M 0X77 6 0X54 N 0X78 7 0X55 O 0X79 8 0X56 P 0X80 9 0X57 Q 0X81 ESC 0X1B R 0X82 CTRL 0X11 S 0X83 SHIFT 0X10 T 0X84 ENTER 0XD 如果要使用组合键，则可以利用event.ctrlKey，event.shiftKey，event .altKey判断是否按下了ctrl键、shift键以及alt键. 作者：大智若简 来自：http://www.cnblogs.com/zxktxj/archive/2012/02/26/2369176.html]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[filter—CSS3滤镜]]></title>
    <url>%2F2016%2F09%2F25%2Ffilter%2F</url>
    <content type="text"><![CDATA[Photoshop有滤镜，想必大家都不陌生，然而在CSS3中也支持了滤镜。 滤镜效果如下： 原图： 高斯模糊filter: blur(5px) 亮度filter: brightness(50%) 对比度filter: contrast(30%); 阴影filter: drop-shadow(10px 10px 5px black); 灰度filter: grayscale(100%); 色相旋转filter: hue-rotate(180deg); 反转filter: invert(100%); 透明度filter: opacity(50%); 饱和度filter: saturate(0%); 深褐色filter: sepia(100%); 转载标明出处或联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式页面的四大核心要素]]></title>
    <url>%2F2016%2F09%2F23%2Fresponsive%2F</url>
    <content type="text"><![CDATA[响应式页面概述1.什么是响应式页面响应式网页（RWD，Responsive Web Design），2010年5月由Ethan Marcotte提出。简而言之，就是一个网站能够针对多个终端提供不同的显示样式，而不是针对每个终端制作一个特定的版本。 由于智能手机和平板电脑的兴起，网站页面的制作不仅要满足PC端浏览器的显示，还要满足智能手机浏览器的显示或者平板电脑浏览器的显示。（PC端、智能手机或平板电脑的浏览器之间的区别，主要集中在分辨率的不同。） 2.为什么需要响应式页面想要同时满足PC端、智能手机和平板电脑浏览器的正常显示，实际上有以下两种实现方式： a.分别针对PC端、智能手机和平板电脑的浏览器制作特定的页面。例如https://www.tmall.com/ 优点：用户体验好，适合复杂页面。 缺点：工作量大，不够灵活。 b.制作一个页面同时满足PC端、智能手机和平板电脑的浏览器显示。例如http://www.intel.cn/ 优点：比较灵活，一个页面适应不同终端。 缺点：页面加载时间长，效率降低。 如果PC端显示的页面与智能手机或平板电脑显示的页面不同时，建议选择a方案。比如智能手机端的可以利用 GPS 定位当前位置等不同于PC端的功能。但大多数网站的页面，无论是PC端还是智能手机或平板电脑显示的内容基本相同，建议选择b方案。 3.响应式页面的构成目前实现响应式页面可以通过以下两种方式： a.使用框架实现，例如 Bootstrap 等。这种方式开发响应式页面更快速、简单，但由于CSS样式是集成式的，导致页面样式相似，没有特点。 b.手写方式实现。这种方式开发响应式页面速度比较慢、代码多，但可以根据网站特点定制CSS样式。 手写方式需要使用到以下几种技术： 流式网格布局 CSS3 的媒体查询 相对单位替换绝对单位 测试响应式页面1.如何测试响应式页面测试响应式页面可以通过以下三种方式： 通过真实设备进行测试。这种方式进行测试效果最好，但也是最复杂，并且需要不同分辨率的设备，成本较高。 通过第三方模拟器进行测试。这种方式一般都是针对智能手机终端研发工具自带，需要在电脑安装不同开发工具，比较麻烦，并且性能较差。或者通过在线测试网站进行测试，测试周期较长。 通过浏览器自带的设备模拟器进行测试。这种方式是最方便的，主流浏览器都自带了设备模拟器，并且测试效果较好。 2.使用浏览器测试以 Chrome 浏览器为例。打开 Chrome 浏览器，点击右上角的菜单，选择“更多工具”中的“开发者工具”。（Windows操作系统版本的 Chrome 浏览器可以通过 F12 快捷键直接打开。） 值得注意的是： 每次更换测试设备时，需要重新刷新页面显示。 有些功能无法正常测试，例如电话薄、摄像头等。 3.使用第三方工具测试4.使用真实设备测试编写响应式页面1.viewport元元素1）什么是 viewport ？viewport 被翻译为“视区”，表示页面的可视区域。通过 HTML 页面的 meta 元元素进行设置，是响应式页面设计的必备内容。 移动端浏览器在一个通常比屏幕更宽的虚拟“窗口”（视口）中渲染页面，从而无序将所有页面都压缩进小屏幕里（那样会把很多没有针对移动端进行优化的站点打乱）。用户可以通过平移和缩放来浏览页面的不同区域。 通过设置 viewport 元元素可以允许开发者控制显示的尺寸及比例。如今大部分移动端浏览器都支持 viewport 元元素，尽管它不是web标准的一部分。 2）设置 viewport一个典型的针对移动端优化的站点包含类似下面的内容： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt; viewport 元元素的属性如下表： 属性名称 说明 可选值 width 设置窗口的宽度 像素值或device-width（表示100%时屏幕宽度的像素值） height 设置窗口的高度 一般不指定 initial-scale 设置初始时的缩放倍率 一般不指定 minimum-scale 设置允许的最小缩放倍率 一般不指定 maximum-scale 设置允许的最大缩放倍率 一般不指定 user-scalable 是否允许用户手动缩放 1或yes表示允许；0或no表示不允许 meta 元元素建议设定在 head 元素中的最前面。 2.使用相对单位1）使用相对宽度值通过学习 CSS 知道设置宽度可以使用 px 像素值和百分值。使用像素值设置宽度是固定值，不能随着屏幕大小变化而变化。实现响应式页面的宽度只能使用百分值或者auto。 如何从固定布局修改为百分比布局在《无懈可击的 Web 设计》一书中，提供了一个简易可行的公式： 目标元素宽度 / 上下文元素宽度 = 百分比宽度 以下代码是使用像素值设置 HTML 页面元素： 123456789div &#123; width : 500px; height : auto; border : 1px solid black;&#125;p &#123; width : 480px; padding-left: 10px;&#125; 将上述像素值修改为百分比： 123456789div &#123; width : 60%; height : auto; border : 1px solid black; &#125;p &#123; width : 96%; /* 480/500=96% */ padding-left: 2%; /* 10/500=2% */&#125; 2）用 em 替换 px之前使用 em 替代 px 设置字体，主要是为了解决老版本的 IE 浏览器无法缩放以像素值为单位的文字。 目前使用 em 替代 px 设置字体，主要的目的具有以下两个： 实现老版本 IE 浏览器可以缩放文字。 更好地实现响应式页面，使页面效果更好。 em 的实际大小事相对于上下文的字体大小而言的，例如 1em 表示与上下文字体相同大小。em 单位设置字体同样可以通过以下公式进行计算： 目标元素尺寸 / 上下文元素尺寸 = 百分比尺寸 值得注意的是：浏览器显示默认文字大小都是 16 像素。 3.流式布局1）什么是流式布局所谓流式布局，就是页面元素的宽度按照屏幕进行适配调整。简单来说，就是 HTML 页面中的元素会根据分辨率的不同而变化大小，但位置并不会有任何变化。 这种布局的主要问题就是，如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。 2）创建流式布局流式布局通常被分为 12 列。将 HTML 页面的宽度设置为 100%，这样 HTML 页面会根据浏览器窗口大小的变化而自动伸缩。 计算每列所占的百分比：100% / 12 列 = 8.33% 根据以上的计算结果，设置 CSS 的 class： 123456789101112.col-1 &#123;width: 8.33%;&#125;.col-2 &#123;width: 16.66%;&#125;.col-3 &#123;width: 25%;&#125;.col-4 &#123;width: 33.33%;&#125;.col-5 &#123;width: 41.66%;&#125;.col-6 &#123;width: 50%;&#125;.col-7 &#123;width: 58.33%;&#125;.col-8 &#123;width: 66.66%;&#125;.col-9 &#123;width: 75%;&#125;.col-10 &#123;width: 83.33%;&#125;.col-11 &#123;width: 91.66%;&#125;.col-12 &#123;width: 100%;&#125; 将所有列设置为浮动（一般为左浮动） 123[class*=&quot;col-&quot;] &#123; float: left;&#125; 将 HTML 页面中所有的元素 box-sizing 设置为 border-box。 当 box-sizing 的值为 content-box（默认值），标准盒模型。尺寸计算公式：width = 内容的宽度，height = 内容的高度。 宽度和高度都不包含内容的边框（border）和内边距（padding）。 123456div &#123; width : 300px; height : 200px; border : 10px solid black; background : deepskyblue;&#125; 当 box-sizing 的值为 border-box，IE 怪异模式（Quirks mode）使用的 盒模型 。尺寸计算公式：width = border + padding + 内容的宽度，height = border + padding + 内容的高度。 注意：外边距和边框将会包括在盒子中。 1234567div &#123; box-sizing: border-box; width : 300px; height : 200px; border : 10px solid black; background : deepskyblue;&#125; 根据上述流式布局的内容，实现以下案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;style&gt; * &#123; box-sizing: border-box; &#125; [class*=&quot;col-&quot;] &#123; float: left; padding: 15px; &#125; .col-1 &#123; width: 8.33%; &#125; .col-2 &#123; width: 16.66%; &#125; .col-3 &#123; width: 25%; &#125; .col-4 &#123; width: 33.33%; &#125; .col-5 &#123; width: 41.66%; &#125; .col-6 &#123; width: 50%; &#125; .col-7 &#123; width: 58.33%; &#125; .col-8 &#123; width: 66.66%; &#125; .col-9 &#123; width: 75%; &#125; .col-10 &#123; width: 83.33%; &#125; .col-11 &#123; width: 91.66%; &#125; .col-12 &#123; width: 100%; &#125; html &#123; font-family: &quot;Lucida Sans&quot;, sans-serif; &#125; header &#123; background-color: #9933cc; color: #ffffff; padding: 15px; &#125; aside ul &#123; list-style-type: none; margin: 0; padding: 0; &#125; aside li &#123; padding: 8px; margin-bottom: 7px; background-color: #33b5e5; color: #ffffff; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24); &#125; aside li:hover &#123; background-color: #0099cc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;h1&gt;Chania&lt;/h1&gt;&lt;/header&gt;&lt;aside class=&quot;col-3&quot;&gt; &lt;ul&gt; &lt;li&gt;The Flight&lt;/li&gt; &lt;li&gt;The City&lt;/li&gt; &lt;li&gt;The Island&lt;/li&gt; &lt;li&gt;The Food&lt;/li&gt; &lt;/ul&gt;&lt;/aside&gt;&lt;article class=&quot;col-9&quot;&gt; &lt;h2&gt;The City&lt;/h2&gt; &lt;p&gt;Chania is the capital of the Chania region on the island of Crete. The city can be divided in two parts, the old town and the modern city.&lt;/p&gt; &lt;p&gt;Resize the browser window to see how the content respond to the resizing.&lt;/p&gt;&lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 4. 响应式图片实现图片的显示根据浏览器窗口大小的变化而变化，相对比较简单。只需要将图片的 width 设置为 100% 即可。 img { width: 100%; height: auto; } 但这样设置后，图片的显示可能会比实际大小更大。解决这个问题可以利用 max-width 替代 width 属性即可。 img { max-width: 100%; height: auto; } 这样设置后，图片的显示永远不会比实际大小更大了。 5. CSS媒体查询想要满足更复杂的情况，需要使用 CSS3 中提供的媒体查询进行解决。 媒体查询 包含了一个媒体类型和至少一个使用如宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。 媒体查询语法媒体查询 包含 一个媒体类型、逻辑操作符和一个或多个媒体属性。如果媒体查询中的媒体类型与文档要展示的设备相符则查询结果为真，并且媒体查询中的所有表达式为真。 媒体查询具体的写法有以下两种方式： link 元素中的 CSS 媒体查询。 1&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;mystylesheet.css&quot;&gt; 这种方式需要针对不同设备编写不同的 CSS 样式表。 样式表中的 CSS 媒体查询。 123@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125; 这种方式只需要编写一个 CSS 样式表，在样式表中根据不同的设备设置不同的样式。（更常用） 媒体类型 值 描述 all 用于所有设备 print 用于打印机和打印预览 screen 设用于电脑屏幕，平板电脑，智能手机等 speech 用于屏幕阅读器等发声设备 媒体类型更常用的值为 screen。 逻辑操作符 值 描述 and 用于把多个 媒体属性 组合起来，合并到同一条媒体查询中。只有当每个属性都为真时，这条查询的结果才为真. not 用于对一条媒体查询的结果进行取反。 only 表示仅在媒体查询匹配成功的情况下应用指定样式。可以通过它让选中的样式在老式浏览器中不被应用。 也可以将多个媒体查询以逗号分隔放在一起；只要其中任何一个为真，整个媒体语句就返回真。相当于 or 操作符。 值 描述 width 定义输出设备中的页面可见区域宽度 max-width 定义输出设备中的页面最大可见区域宽度 max-device-width 定义输出设备的屏幕最大可见宽度 min-width 定义输出设备中的页面最小可见区域宽度 min-device-width 定义输出设备的屏幕最小可见宽度 媒体查询示例link 元素中的 CSS 媒体查询 HTML 代码 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;LINK元素方式的媒体查询&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/main.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (min-width:768px)&quot; href=&quot;css/pc.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (max-width:768px)&quot; href=&quot;css/phone.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;h1&gt;Chania&lt;/h1&gt;&lt;/header&gt;&lt;aside class=&quot;col-3&quot;&gt; &lt;ul&gt; &lt;li&gt;The Flight&lt;/li&gt; &lt;li&gt;The City&lt;/li&gt; &lt;li&gt;The Island&lt;/li&gt; &lt;li&gt;The Food&lt;/li&gt; &lt;/ul&gt;&lt;/aside&gt;&lt;article class=&quot;col-9&quot;&gt; &lt;h2&gt;The City&lt;/h2&gt; &lt;p&gt;Chania is the capital of the Chania region on the island of Crete. The city can be divided in two parts, the old town and the modern city.&lt;/p&gt; &lt;p&gt;Resize the browser window to see how the content respond to the resizing.&lt;/p&gt;&lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 针对分辨率的宽度在 768px 之上的样式表 12345678910111213141516171819202122232425262728293031323334353637383940.col-1 &#123; width: 8.33%;&#125;.col-2 &#123; width: 16.66%;&#125;.col-3 &#123; width: 25%;&#125;.col-4 &#123; width: 33.33%;&#125;.col-5 &#123; width: 41.66%;&#125;.col-6 &#123; width: 50%;&#125;.col-7 &#123; width: 58.33%;&#125;.col-8 &#123; width: 66.66%;&#125;.col-9 &#123; width: 75%;&#125;.col-10 &#123; width: 83.33%;&#125;.col-11 &#123; width: 91.66%;&#125;.col-12 &#123; width: 100%;&#125;[class*=&quot;col-&quot;] &#123; float: left; padding: 15px;&#125; 针对分辨率的宽度在 768px 之下的样式表 1234[class*=&quot;col-&quot;] &#123; width: 100%; padding: 15px;&#125; 样式表中的 CSS 媒体查询 HTML 代码 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS样式表中的媒体查询&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/main.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/media.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;h1&gt;Chania&lt;/h1&gt;&lt;/header&gt;&lt;aside class=&quot;col-3&quot;&gt; &lt;ul&gt; &lt;li&gt;The Flight&lt;/li&gt; &lt;li&gt;The City&lt;/li&gt; &lt;li&gt;The Island&lt;/li&gt; &lt;li&gt;The Food&lt;/li&gt; &lt;/ul&gt;&lt;/aside&gt;&lt;article class=&quot;col-9&quot;&gt; &lt;h2&gt;The City&lt;/h2&gt; &lt;p&gt;Chania is the capital of the Chania region on the island of Crete. The city can be divided in two parts, the old town and the modern city.&lt;/p&gt; &lt;p&gt;Resize the browser window to see how the content respond to the resizing.&lt;/p&gt;&lt;/article&gt;&lt;/body&gt;&lt;/html&gt; CSS 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* For desktop: */.col-1 &#123; width: 8.33%;&#125;.col-2 &#123; width: 16.66%;&#125;.col-3 &#123; width: 25%;&#125;.col-4 &#123; width: 33.33%;&#125;.col-5 &#123; width: 41.66%;&#125;.col-6 &#123; width: 50%;&#125;.col-7 &#123; width: 58.33%;&#125;.col-8 &#123; width: 66.66%;&#125;.col-9 &#123; width: 75%;&#125;.col-10 &#123; width: 83.33%;&#125;.col-11 &#123; width: 91.66%;&#125;.col-12 &#123; width: 100%;&#125;[class*=&quot;col-&quot;] &#123; float: left; padding: 15px;&#125;@media only screen and (max-width: 768px) &#123; /* For mobile phones: */ [class*=&quot;col-&quot;] &#123; width: 100%; &#125;&#125; 来自：http://blog.longestory.com/Css/writing-responsive-web-design.html]]></content>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入了解font-weight]]></title>
    <url>%2F2016%2F09%2F19%2Ffont-weight%2F</url>
    <content type="text"><![CDATA[问题提出font-weight的属性值有100、200、300、400、500、600、700、800、900和normal、bold、lighter、bolder，它们的区别是？ 另外，在实际开发中，我们应该使用数值表达还是文字表达呢？ 认识font-weight根据W3C Fonts节章的规范标准，可知： font-weight可取值：100～900和normal、bold、bolder、lighter。 100～900、normal、bold如果字体使用九阶有序数值100～900来划分其字重(字体的粗细度)，那么样式指定的font-weight属性值与字体的字重则一一对应。并且normal等价于400，bold等价于700。 但实际上，我们一般遇到的字体很多时候都是使用一些通用的词描述划分其字重，如下所示。 常见的字重数值大致对应的字重描述词语： 100 - Thin 200 - Extra Light (Ultra Light) 300 - Light 400 - Regular (Normal、Book、Roman) 500 - Medium 600 - Semi Bold (Demi Bold) 700 - Bold 800 - Extra Bold (Ultra Bold) 900 - Black (Heavy) 1为什么说大致对应呢？在有些字库下是有差异的，比如在Adobe Typekit字库中对字重描述的划分列表中，它列出Heavy指的是800而不是900。另外，在我们日常使用的Photoshop和Sketch里面，Ultra Light是100，而Thin是200。 并且，字体所拥有的字重的数量实际上很少存在满足有9个字重刚好跟100～900的CSS字重一一对应的情况，通常字体拥有的字重数量为4至6个。 不必担心，起码400和700对应的字重至少是每种字体必备的，譬如常见的 Arial、Helvetica、Georgia等等，只有400(normal)和700(bold)。 bolder、lighterbolder、lighter表示其字重值是基于从其父元素继承而来的字重计算所得的，与normal、bold所代表的字重并无关系。 其值通常是根据下表计算而得的： 继承值（Inherited value） bolder所代表的字重 lighter所代表的字重 100 400 100 200 400 100 300 400 100 400 700 100 500 700 100 600 900 400 700 900 400 800 900 700 900 900 700 字体匹配算法在上面我们已经提到，在很多情况下，字体并不是以九阶数值来划分的，并且其含有的字重数量是不一的，通常情况下为4-6个。 此时，就会出现样式指定的字重数值在字体中找不到直接对应的字重，那浏览器是如何解决的呢？ Bingo！ 那就是要靠字体匹配算法来解决。其中关于font-weight部分是这么提及到的： 讲人话就是： 如果指定的font-weight数值，即所需的字重，能够在字体中找到对应的字重，那么就匹配为该对应的字重。否则，使用下面的规则来查找所需的字重并渲染： 如果所需的字重小于400，则首先降序检查小于所需字重的各个字重，如仍然没有，则升序检查大于所需字重的各字重，直到找到匹配的字重。 如果所需的字重大于500，则首先升序检查大于所需字重的各字重，之后降序检查小于所需字重的各字重，直到找到匹配的字重。 如果所需的字重是400，那么会优先匹配500对应的字重，如仍没有，那么执行第一条所需字重小于400的规则。 如果所需的字重是500，则优先匹配400对应的字重，如仍没有，那么执行第二条所需字重大于500的规则。 感谢来自@何洋的补充：大多数浏览器已实现font-synthesis属性，使用该属性可以控制在font-weight没有相匹配的font typeface时，会模拟计算出合适的渲染字重(与其应有的typeface有些差异)，从而忽略Font Matching Algorithm。参考文章： Fonts－字体匹配算法第5条 MDN－font-synthesis 理解与运用下面我们通过官方例子和实际测试来好好理解这个匹配算法规则。 官方例子W3C规范标准中给出这么一个例子： 注解：灰色标记的是字体中缺少的字重，而黑色则是字体拥有的字重。 基于匹配算法规则，看图理解所得： Figure 15.图指的是 字体库内直接匹配的字重 填空值(即通过算法间接匹配所得字重) 400 300、200、100、500 700 600 900 800 拿font-weight: 300;来说，字体中没有可以直接匹配的字重，那么300小于400，则根据第一条规则，先降序查找匹配，但是都没有可匹配的200、100，那么升序查找为400，结果可匹配。 Figure 16.图指的是 字体库内直接映射的字重 填空值 300 200、100、400、500 600 700、800、900 这里需要注意的是，填空值500表现的是300的字重，而不是600的字重。 为什么呢？根据结果表现，我们可以反推出，字重在浏览器去渲染时早已经按照算法去一一匹配好。也就是，400匹配的字重在500匹配之前已经匹配好了（说起来有点拗口，大家可以根据Figure.16的例子体会下）。 其余的，我就不多解释了，大家可以根据结果检查自己是否理解到位。 实际测试——Droid Sans 根据Google Fonts API - Droid Sans提供的Droid Sans字体，我们可以知道该字体拥有两种字重。 根据字体匹配算法规则，我们可以预测其字重匹配应该如下表所示： 字体库内直接映射的字重 填空值 400 300、200、100、500 700 600、800、900 也就是100、200、300、500会表现为跟400同一种字重，600、800、900会表现为跟700同一种字重。 利用Google Fonts提供的Droid Sans，我们进行了实例测试－(DroidSans.html)来验证。 结果如下图，证明我们的预测结果正确，该字体匹配算法规则运行有效。 总结根据以上的研究，可以总结出三点： 通常情况下，一个特定的字体仅会包含少数的可用字重。若所指定的字重不存在直接匹配，则会通过字体匹配算法规则匹配使用邻近的可用字重。这也就是为什么我们有时候使用特定字重时没有“生效”，看起来跟其它字重差不多的原因所在。 在实际中，最为常用的字重是normal和bold。我个人认为400、700是等效于normal、bold的，无论哪一种表示方法都没有关系，主要是个人习惯问题。 但是，推荐使用数值替代lighter、bolder，因为这涉及到继承计算的问题，用数值的话则会更为清晰明了。 来自：凹凸实验室 https://aotu.io/notes/2016/11/08/css3fontweight/]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面试题]]></title>
    <url>%2F2016%2F09%2F19%2Finterview%2F</url>
    <content type="text"><![CDATA[前言年前刚刚离职了，分享下我曾经出过的一道面试题，此题是我出的一套前端面试题中的最后一题，用来考核面试者的JavaScript的综合能力，很可惜到目前为止的将近两年中，几乎没有人能够完全答对，并非多难只是因为大多面试者过于轻视他。 题目如下： 1234567891011121314151617function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;Foo.getName = function () &#123; alert (2);&#125;;Foo.prototype.getName = function () &#123; alert (3);&#125;;var getName = function () &#123; alert (4);&#125;;function getName() &#123; alert (5);&#125;//请写出以下输出结果：Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName(); 答案是： 1234567891011121314151617function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;Foo.getName = function () &#123; alert (2);&#125;;Foo.prototype.getName = function () &#123; alert (3);&#125;;var getName = function () &#123; alert (4);&#125;;function getName() &#123; alert (5);&#125;//答案：Foo.getName();//2getName();//4Foo().getName();//1getName();//1new Foo.getName();//2new Foo().getName();//3new new Foo().getName();//3 此题是我综合之前的开发经验以及遇到的JS各种坑汇集而成。此题涉及的知识点众多，包括变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等等。 此题包含7小问，分别说下。 第一问先看此题的上半部分做了什么，首先定义了一个叫Foo的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个叫getName函数。 第一问的Foo.getName自然是访问Foo函数上存储的静态属性，自然是2，没什么可说的。 第二问第二问，直接调用getName函数。既然是直接调用那么就是访问当前上文作用域内的叫getName的函数，所以跟1 2 3都没什么关系。此题有无数面试者回答为5。此处有两个坑，一是变量声明提升，二是函数表达式。 变量声明提升即所有声明变量或声明函数都会被提升到当前函数的顶部。 例如下代码: console.log(&apos;x&apos; in window);//true var x; x = 0; 代码执行时js引擎会将声明语句提升至代码最上方，变为： var x; console.log(&apos;x&apos; in window);//true x = 0; 函数表达式var getName与function getName都是声明语句，区别在于var getName是函数表达式，而function getName是函数声明。关于JS中的各种函数创建方式可以看大部分人都会做错的经典JS闭包面试题这篇文章有详细说明。 函数表达式最大的问题，在于js会将此代码拆分为两行代码分别执行。 例如下代码： console.log(x);//输出：function x(){} var x=1; function x(){} 实际执行的代码为，先将var x=1拆分为var x;和x = 1;两行，再将var x;和function x(){}两行提升至最上方变成： var x; function x(){} console.log(x); x=1; 所以最终函数声明的x覆盖了变量声明的x，log输出为x函数。 同理，原题中代码最终执行时的是： 123456789101112function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;var getName;//只提升变量声明function getName() &#123; alert (5);&#125;//提升函数声明，覆盖var的声明Foo.getName = function () &#123; alert (2);&#125;;Foo.prototype.getName = function () &#123; alert (3);&#125;;getName = function () &#123; alert (4);&#125;;//最终的赋值再次覆盖function getName声明getName();//最终输出4 第三问第三问的Foo().getName();先执行了Foo函数，然后调用Foo函数的返回值对象的getName属性函数。 Foo函数的第一句getName = function () { alert (1); };是一句函数赋值语句，注意它没有var声明，所以先向当前Foo函数作用域内寻找getName变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有getName变量，找到了，也就是第二问中的alert(4)函数，将此变量的值赋值为function(){alert(1)}。 此处实际上是将外层作用域内的getName函数修改了。 注意：此处若依然没有找到会一直向上查找到window对象，若window对象中也没有getName属性，就在window对象中创建一个getName变量。 之后Foo函数的返回值是this，而JS的this问题博客园中已经有非常多的文章介绍，这里不再多说。 简单的讲，this的指向是由所在函数的调用方式决定的。而此处的直接调用方式，this指向window对象。 遂Foo函数返回的是window对象，相当于执行window.getName()，而window中的getName已经被修改为alert(1)，所以最终会输出1 此处考察了两个知识点，一个是变量作用域问题，一个是this指向问题。 第四问直接调用getName函数，相当于window.getName()，因为这个变量已经被Foo函数执行时修改了，遂结果与第三问相同，为1 第五问第五问new Foo.getName();，此处考察的是js的运算符优先级问题。 js运算符优先级: 参考链接：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence 通过查上表可以得知点（.）的优先级高于new操作，遂相当于是: new (Foo.getName)(); 所以实际上将getName函数作为了构造函数来执行，遂弹出2。 第六问第六问new Foo().getName()，首先看运算符优先级括号高于new，实际执行为 (new Foo()).getName() 遂先执行Foo函数，而Foo此时作为构造函数却有返回值，所以这里需要说明下js中的构造函数返回值问题。 构造函数的返回值在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。 而在js中构造函数可以有返回值也可以没有。 1、没有返回值则按照其他语言一样返回实例化对象。 2、若有返回值则检查其返回值是否为引用类型。如果是非引用类型，如基本类型（string,number,boolean,null,undefined）则与无返回值相同，实际返回其实例化对象。 3、若返回值是引用类型，则实际返回值为这个引用类型。 原题中，返回的是this，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象。 之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，遂到当前对象的原型对象（prototype）中寻找getName，找到了。 遂最终输出3。 第七问第七问,new new Foo().getName();同样是运算符优先级问题。 最终实际执行为： new ((new Foo()).getName)(); 先初始化Foo的实例化对象，然后将其原型上的getName函数作为构造函数再次new。 遂最终结果为3 ===2016年03月23日更新=== 这里引用 @于明昊 的评论，更详细的解释了第7问： 这里确实是(new Foo()).getName()，但是跟括号优先级高于成员访问没关系，实际上这里成员访问的优先级是最高的，因此先执行了 .getName，但是在进行左侧取值的时候， new Foo() 可以理解为两种运算：new 带参数（即 new Foo()）和函数调用（即 先 Foo() 取值之后再 new），而 new 带参数的优先级是高于函数调用的，因此先执行了 new Foo()，或得 Foo 类的实例对象，再进行了成员访问 .getName。 最后就答题情况而言，第一问100%都可以回答正确，第二问大概只有50%正确率，第三问能回答正确的就不多了，第四问再正确就非常非常少了。其实此题并没有太多刁钻匪夷所思的用法，都是一些可能会遇到的场景，而大多数人但凡有1年到2年的工作经验都应该完全正确才对。 只能说有一些人太急躁太轻视了，希望大家通过此文了解js一些特性。 并祝愿大家在新的一年找工作面试中胆大心细，发挥出最好的水平，找到一份理想的工作。 作者：作者：小小沧海出处：http://www.cnblogs.com/xxcanghai/来自地址：http://www.cnblogs.com/xxcanghai/p/5189353.html]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS中的浮动和清除浮动]]></title>
    <url>%2F2016%2F09%2F18%2Fclear-float%2F</url>
    <content type="text"><![CDATA[从业三年，项目无数，现在回过头来，想要把一些重要的知识用白话整理出来：这个东西是什么？怎样才是最佳实践？希望对自己知识体系有梳理作用， 也希望对大家有些许帮助。 前端技术栈更新太快，眼花缭乱，大家一个劲揽过来学习的时候，别忘了回头看看那些已经掌握的基础知识。 第一篇就整理整理CSS中很常见的浮动以及清除浮动的一些方式吧。 浮动到底是什么？浮动核心就一句话：浮动元素会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素。请默念3次！ 浮动最初设计的目的并没那么多事儿，就只是用来实现文字环绕效果而已，如下所示： 文字环绕效果 但是早期的前端开发者发现：浮动的元素可以设置宽高并且可以内联排列，是介于inline和block之间的一个神奇的存在，在inline-block出来之前，浮动大行其道。直到inline-block出来后，浮动也有它自己独特的使用场景。 浮动有哪些特征？浮动的特征就体现在前文的那句话中，别忘了默念三次！此外，浮动带来的负效果也算是它的特征之一。 浮动会脱离文档脱离文档，也就是说浮动不会影响普通元素的布局 浮动会脱离文档流 从上图可以看出，默认三个设置了宽高的block元素，本来会格子独占一行；如果框1设置了向左/向右浮动，他会忽略框2和框3，直到碰到父元素；同时也存在盖住普通元素的风险。 浮动可以内联排列浮动会向左/向右浮动，直到碰到另一个浮动元素为止，这是浮动可以内联排列的特征。也就是说，浮动可以设置宽高，并且能够一行多个，是介于block和inline之间的存在。 浮动可以内联排列 从上图可以看出，对多个元素设置浮动，可以实现类似inline-block的效果；但是如果每个元素的高度不一致，会出现“卡住”的情况。 浮动会导致父元素高度坍塌浮动会脱离文档流，这个问题对整个页面布局有很大的影响。 // css .box-wrapper { border: 5px solid red; } .box-wrapper .box { float: left; width: 100px; height: 100px; margin: 20px; background-color: green; } // html &lt;div class=&quot;box-wrapper&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; 结果如下，浮动元素脱离了文档流，并不占据文档流的位置，自然父元素也就不能被撑开，所以没了高度。 父元素高度坍塌 那怎么办呢？那就需要我们清除浮动，来解决高度坍塌问题！清除浮动主要有两种方式，分别是clear清除浮动和BFC清除浮动，其他的你也不用去了解了。 clear如何清除浮动？clear属性不允许被清除浮动的元素的左边/右边挨着浮动元素，底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间。这句话，请默念5次！ 要注意了，我们是通过在别的元素上清除浮动来实现撑开高度的， 而不是在浮动元素上。 还是接着上面的例子，我们简单修改一下HTML代码，如下 &lt;div class=&quot;box-wrapper&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt; &lt;/div&gt; clear清除浮动 高度坍塌的问题解决了，至此，好像浮动我们可以随便玩了，真棒！ 不要在浮动元素上清除浮动但是有人问到，如果我们给第三个元素加上clear:both，结果会怎样？ &lt;div class=&quot;box-wrapper&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot; style=&quot;clear:both;&quot;&gt;&lt;/div&gt; &lt;/div&gt; 不要在浮动元素上清除浮动 诶？给第三个元素加上clear:both之后，第三个元素的左右都没有挨着浮动元素，但是为什么高度还是坍塌了呢？机智的你可能发现了，由于第三个元素是浮动元素，脱离了文档流，就算给第三个元素上下加了清除空间，也是没有任何意义的。 clear清除浮动最佳实践那么clear清除浮动的最佳实践是什么呢？请看如下代码： 1234567891011121314151617181920212223242526272829303132// 现代浏览器clearfix方案，不支持IE6/7.clearfix:after &#123; display: table; content: &quot; &quot;; clear: both;&#125;// 全浏览器通用的clearfix方案// 引入了zoom以支持IE6/7.clearfix:after &#123; display: table; content: &quot; &quot;; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125;// 全浏览器通用的clearfix方案【推荐】// 引入了zoom以支持IE6/7// 同时加入:before以解决现代浏览器上边距折叠的问题.clearfix:before,.clearfix:after &#123; display: table; content: &quot; &quot;;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125; clearfix清除浮动 一句话，强烈推荐clearfix的方式清除浮动！ BFC清除浮动BFC全称是块状格式化上下文，它是按照块级盒子布局的。我们了解他的特征、触发方式、常见使用场景这些就够了。 BFC的主要特征 BFC容器是一个隔离的容器，和其他元素互不干扰；所以我们可以用触发两个元素的BFC来解决垂直边距折叠问题。 BFC可以包含浮动；通常用来解决浮动父元素高度坍塌的问题。 其中，BFC清除浮动就是用的“包含浮动”这条特性。那么，怎样才能触发BFC呢？ BFC的触发方式我们可以给父元素添加以下属性来触发BFC： float为left|right overflow为hidden|auto|scorll display为table-cell|table-caption|inline-block|flex|inline-flex position为absolute|fixed 所以我们可以给父元素设置overflow:auto来简单的实现BFC清除浮动，但是为了兼容IE最好用overflow:hidden。但是这样元素阴影或下拉菜单会被截断，比较局限。 .box-wrapper{ overflow: hidden; } 浮动的适用场景有哪些？文字环绕效果这个不用说了，浮动本来就是为文字环绕效果而生，这是最基本的 文字环绕效果 页面布局浮动可以实现常规的多列布局，但个人推荐使用inline-block。 浮动更适合实现自适应多列布局，比如左侧固定宽度，右侧根据父元素宽度自适应。 页面布局 多个元素内联排列如果前文提到的，浮动可以实现类似inline-block的排列，比如菜单多个元素内联排列。但个人推荐使用inline-block。 多个元素内联排列 又来点总结？本来只是想简单说说浮动的背景、浮动的问题，浮动的解决方案，但真整理起来的时候，又发现很多知识点需要扩展，很多东西需要掰扯，一文难以言尽，所以只挑一些我觉得比较主流比较重要的知识写出来，如果有兴趣可以自行展开。 浮动最初设计只是用来实现文字环绕排版的。 浮动的三个特点很重要。 脱离文档流。 向左/向右浮动直到遇到父元素或者别的浮动元素。 浮动会导致父元素高度坍塌。 解决父元素高度坍塌的方式就是清除浮动，常规的方法是clear清除浮动和BFC清除浮动，推荐clearfix的方式。一定要弄清楚clear清除浮动的底层原理以及clearfix的那几行代码的具体作用。 BFC有自己的特征，也有触发BFC的方式，这儿就不展开太多了。 IE6/7不支持BFC，也不支持:after，所以IE6/7清除浮动要靠触发hasLayout，了解下就行，毕竟IE6/7已经是历史的产物了。 写这些文章主要目的是为了梳理知识点，没有固定计划，想到哪写到哪，如果大家有想了解的话，可以留言，我会结合经验梳理知识，并告诉你为什么要这样，怎么样做才是最佳实践 （简书作者）:文／齐修_qixiuss原文链接：http://www.jianshu.com/p/09bd5873bed4]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深刻理解JavaScript---闭包]]></title>
    <url>%2F2016%2F09%2F15%2Fclosure%2F</url>
    <content type="text"><![CDATA[闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。换句话说，这些函数可以“记忆”它被创建时候的环境。——这句话其实有点难以理解。我觉得应该用一些例子来理解闭包的含义。 闭包#1先来看一个函数: 123456function f()&#123; var b = &quot;b&quot;; return function()&#123; return b; &#125;&#125; 这个函数含有一个局部变量b，它在全局空间里面是不可见的。而f()的返回值是另一个匿名函数，该函数有自己的私有的空间，可以访问f()的空间和全局空间，所以b对它来说是可见的。 var n = f(); n();//此时控制台输出&quot;b&quot; 因为f()是一个全局函数，它可以在全局空间被调用，当然也可以将其返回值赋值给另一个全局变量n，从而生成一个可以访问f()私有空间的新的全局函数。 闭包#2再来看看下面这个跟上面差不多的函数,在这里f()不再返回函数了，而是直接在函数体内创建一个新的全局函数 123456789var n;function f()&#123; var b = &quot;b&quot;; n = function()&#123; return b; &#125;&#125;f();n();//调用f()，然后再调用n(),控制台输出&quot;b&quot; 由于n()没有使用var语句，因此它是全局的，同时它也可以访问f()的作用域，所以哪怕n()最后升级为全局函数，但它依然可以保留对f()作用域的访问权。 闭包#3函数通常会让自身的参数视为局部变量，所以我们创建返回函数时，也可以令其返回父级函数的参数，例如： 123456789function f(arg)&#123; var n = function()&#123; return arg; &#125;; arg++; return n;&#125;var m = f(123);m();//调用函数，输出124 有一点很重要：n被赋值时函数并没有被调用，调用发生是在n被求值，也就是执行return n;语句时。由此可以看出，函数所绑定的是作用域本身，而不是该作用域中的变量或变量当前所返回的值。 循环中的闭包#4这种闭包所导致的bug往往很难被发现，因为它们表面上看起来很正常，来看一下下面的函数 123456789101112131415function f()&#123; var a = []; var i; for (i = 0; i &lt; 3; i++)&#123; a[i] = function()&#123; return i; &#125; &#125; return a;&#125;//下面来运行一下函数，并将结果赋值给数组avar a = f();a[0]();//输出3a[1]();//输出3a[2]();//输出3 为啥不是0、1、2呢？为啥会这样呢？原来在这里创建的三个闭包，它们都指向了一个共同的局部变量i，但是，闭包不会记录它们的值，它们所拥有的的只是一个i的连接（即引用），因此只能返回i当前值，因为i结束循环时值为3，所以这三个函数都指向一个共同值3 如何纠正？显然，需要a[i]指向三个不同的变量，下面是解决方案之一： 1234567891011121314151617function f()&#123; var a = []; var i; for (i = 0; i &lt; 3; i++)&#123; a[i] = (function(x)&#123; return function()&#123; return x; &#125; &#125;)(i); &#125; return a;&#125;//下面来运行一下函数，并将结果赋值给数组avar a = f();a[0]();//输出0a[1]();//输出1a[2]();//输出2 这里使用了自调函数，不再直接返回i的值，而是将i传递给自调函数，i赋值给了局部变量x，这样一来，每次迭代x就会拥有各自不同的值了。 解决方案二： 12345678910111213function f()&#123; function aa(x)&#123; return function()&#123; return x; &#125; &#125; var a = []; var i; for (i = 0; i &lt; 3; i++)&#123; a[i] = aa(i); &#125; return a;&#125; 方案二不使用自调函数，而是定义了一个内部函数实现相同的功能，每次迭代操作中，将i的值“本地化”。 Getter与Setter、 迭代器 闭包的应用示例#512345678910111213var getValue, setValue;(function()&#123; var temp = 0; getValue = function()&#123; return temp; &#125;; setValue = function(v)&#123; temp = v; &#125;&#125;)();getValue();//输出0setValue(123)getValue();//输出123 这个例子是通过一个匿名自调函数来实现的，定义的全局函数setValue()和getValue()，确保局部变量temp的不可直接访问性。 下面是一个接受数组输入的初始化函数，其中定义了一个私有指针，该指针会指向数组中的下一个元素。 123456789101112function setup(x)&#123; var i = 0; return function() &#123; return x[i++]; &#125;;&#125;//调用setup()，创建我们所需的next()函数var next = setup([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);//重复调用next()，就可以不停的获取下一个元素next();//输出&quot;a&quot;next();//输出&quot;b&quot;next();//输出&quot;c&quot; 到这里闭包就暂时告一段落了，以后有新的理解再写。 作者：yuzmb 来自：https://yuzmb.github.io/2016/10/29/%E7%90%86%E8%A7%A3JavaScript---%E9%97%AD%E5%8C%85/]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用CSS3来制作倒影（box-reflect）]]></title>
    <url>%2F2016%2F09%2F13%2Fbox-reflect%2F</url>
    <content type="text"><![CDATA[有一句话说的好：“横看成岭侧成峰，远近高低各不同”，有些时候，我们需要从不同的角度去欣赏mm，如下图： 在早期，要实现这种效果，我们只能乖乖的找设计去制作，然后在页面上插入一张图片，但是随着CSS3的出现，我们可以纯代码实现，如何实现呢？就是通过CSS3的box-reflect属性。 兼容性既然是CSS3的属性，我们当然要来看看兼容性：点击查看 接下来，我们来了解box-reflect如何使用？ 语法如下： -webkit-box-reflect：none | ? ? box-reflect:none | ? ? 属性说明：none：此值为默认值，表示无倒影； direction：生成倒影的方向 above：指定倒影在对象的上边 below：指定倒影在对象的下边 left：指定倒影在对象的左边 right：指定倒影在对象的右边 offset：图片与倒影间隔 length：用长度值来定义倒影与对象之间的间隔。可以为负值percentage：用百分比来定义倒影与对象之间的间隔。可以为负值 mask-box-image：用来设置倒影的遮罩效果； 值可以是： none：无遮罩图像url：使用绝对或相对地址指定遮罩图像。linear-gradient：使用线性渐变创建遮罩图像。radial-gradient：使用径向(放射性)渐变创建遮罩图像。repeating-linear-gradient：使用重复的线性渐变创建背遮罩像。repeating-radial-gradient`：使用重复的径向(放射性)渐变创建遮罩图像。 光是纸上谈兵可不行，我们还是要通过实例来看看效果。 倒影的方向在这个例子中，我弄了三个img： css如下： 12345678910111213141516171819.box1,.box2,.box3&#123; width:120px; float:left; margin-right:180px;&#125;img&#123; width:100%;&#125;.box1 img&#123; -webkit-box-reflect:right; box-reflect:right;&#125;.box2 img,.box3 img&#123; -webkit-box-reflect: above; box-reflect:above;&#125;.box3&#123; padding-top:200px;&#125; 效果图如下： 在这里有一个疑问，box2和box3中的图片都设置了box-reflect:above，都是在顶部生成投影，为什么box2看不到效果呢？原因就是我给box3设置了padding-top:200px，而box2没有，初步估计是因为没有空间让其显示生成的倒影。 倒影与对象之间的距离了解了生成倒影的方向后，我们来看第二个属性，还是看例子： 依旧用三张图片，不过样式改变一下： 123456789101112.box1 img&#123; -webkit-box-reflect:below 30px; box-reflect:below 30px;&#125;.box2 img&#123; -webkit-box-reflect:below -30px; box-reflect:below -30px;&#125;.box3 img&#123; -webkit-box-reflect:below 5%; box-reflect:below 5%;&#125; 效果图如下： 接下来我们学习最后一个属性。 遮罩效果（1）使用渐变给倒影添加遮罩效果.box1 img{ -webkit-box-reflect:below 0 -webkit-linear-gradient(top,rgba(250,250,250,0),rgba(250,250,250,.0) 30%,rgba(250,250,250,.3)); box-reflect:below 0 linear-gradient(top,rgba(250,250,250,0),rgba(250,250,250,.0) 30%,rgba(250,250,250,.3)); } 效果如下： 使用背景图给倒影添加遮罩效果首先我们需要一张五角星的png图片： .box2 img{ -webkit-box-reflect:below 0 url(http://7s1r1c.com1.z0.glb.clouddn.com/t_star.png); box-reflect:below 0 url(http://7s1r1c.com1.z0.glb.clouddn.com/t_star.png); } 效果如下： 到这里，关于CSS3的box-reflect属性的语法和使用已经介绍完了。 作者：铁锅 来自：http://gold.xitu.io/post/5822e2f32e958a12991e4e50?utm_source=gold_browser_extension]]></content>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你所不知道的 Console]]></title>
    <url>%2F2016%2F09%2F12%2Fconsole%2F</url>
    <content type="text"><![CDATA[1.凡人视角 打印字符串代码： console.log(&quot;I am a 凡人&quot;); 打印提示消息代码： console.info(&quot;Yes, you arm a 凡人&quot;); 打印警告消息代码： console.warn(&quot;凡人你居然敢窥视我&quot;); 打印错误消息代码： console.error(&quot;天兵天将，把这个凡人给我打入地狱&quot;); 打印调试信息console.debug(&quot;我就是传说中的debug&quot;); 2.上帝视角 查看所有方法console除了上面的几个方法还有什么方法呢？log除了能打印字符串外，还能打印出对象，我们可以利用console.log打印自己。 代码： console.log(console); 输出： Object { assert: ..., clear: ..., count: ..., debug: ..., dir: ..., dirxml: ..., error: ..., group: ..., groupCollapsed: ..., groupEnd: ..., info: ..., log: ..., markTimeline: ..., profile: ..., profileEnd: ..., table: ..., time: ..., timeEnd: ..., timeStamp: ..., timeline: ..., timelineEnd: ..., trace: ..., warn: ... } 啊咧咧？怎么这么多方法。其实上面的console方法不一定每个浏览器都有实现，我这边使用的是chrome浏览器。所以说，这个特性是非标准的，请尽量不要在生产环境中使用它。 但是我们可以在开发环境中，合理的利用这些方法来帮助我们开发。 清理控制台如果我们在控制台调试的时候，难免强迫症发作想清理掉已经乱七八糟的控制台。浏览器和命令行clear一样提供了一个清理函数console.clear()。 console.clear() 当然我们也可以用chrome的command line api来清理控制台。 clear() 又或者可以使用按键Mac上cmd + k，Winctrl + l（我用的是chrome浏览器）。 分组当代码非常长，或者我们需要把一个函数，或者一个文件中的函数等区分出来。我们可以使用分组来实现。 代码： console.group(&apos;凡人&apos;); console.log(&quot;手&quot;); console.log(&quot;脚&quot;); console.groupEnd(); console.group(&apos;神&apos;); console.log(&quot;法力无边&quot;); console.log(&quot;腾云架雾&quot;); console.groupEnd(); 输出： 如果想要输出为折叠，我们可以使用console.groupCollapsed，用法和console.group类似。 查看对象信息有时候我们需要打印出对象信息,可以使用 console.log来进行简单的输出。 代码： var person = { head: 1, hand: 2, leg: 2 }; console.log(person); 呜呜，可是这个显示得好丑，我们这个时候就可以使用传说中的神器console.table来帮助我们清楚的显示关联数组信息。 1234567891011var data = [ &#123; &apos;姓名&apos;: &apos;幼儿园&apos;, &apos;性别&apos;: &apos;女&apos; &#125;, &#123; &apos;姓名&apos;: &apos;李狗嗨&apos;, &apos;数量&apos;: 1 &#125;];console.table(data); 输出： 但是如果想要看详细的对象信息，我们可以使用console.dir，将一个JavaScript对象的所有属性和属性值显示成一个可交互的列表，它还能打印出函数等。 console.dir(clear); 什么？你想看某个节点中的html代码？没事，我们可以用console.dirxml来查看页面中对应元素的html/xml内容。 html代码： &lt;div id=&apos;person&apos;&gt; &lt;p&gt;I am a 凡人&lt;/p&gt; &lt;/div&gt; javascirpt代码： var person = document.getElementById(&apos;person&apos;); console.dirxml(person)； 性能测试雷军粑粑老是喜欢说：“不服？跑个分。”有时候，我们也需要对代码跑个分。这个时候，我们可以使用console.time和console.timeEnd，他们可以记录代码运行所花费的时间。 123456789101112console.time(&quot;神机妙算&quot;);(function () &#123; for(var i = 0; i &lt; 10; i++) &#123; var sum = (function () &#123; var flog = 0; for(var i = 0; i &lt; 10; i++) &#123; flog+=i; &#125; &#125;)(); &#125;&#125;)();console.timeEnd(&quot;神机妙算&quot;); 啊咧咧？你这个顶多就是计时器怎么能说是性能测试。客官别急，我们这还有一个叫做console.profile和console.profileEnd姐妹呢~~ 123456789101112console.profile(&quot;神机妙算&quot;);(function () &#123; for(var i = 0; i &lt; 10; i++) &#123; var sum = (function () &#123; var flog = 0; for(var i = 0; i &lt; 10; i++) &#123; flog+=i; &#125; &#125;)(); &#125;&#125;)();console.profileEnd(&quot;神机妙算&quot;); 输出会显示在profile 什么还是不够？你还想知道运行时的结果栈？可以可以，我们这还有一位console.trace哦。他可以看透大爷你的一局一动哦。 代码： 1234567891011function add(num) &#123; if (0 &lt; num) &#123; console.trace(&quot;现在num的值为&quot;, num); return num + add(num - 1); &#125; else &#123; return 0; &#125;&#125;var a =3;add(3); 输出： 判断真假平时我们在写代码是时候，经常需要判断一下当前值的真假情况，使用if或者三元表达式来达到目的。我们现在也可以使用console.assert来判断，该方法会在条件为错误时，返回一个console.error的输出。 console.assert(1 == 1); console.assert(1 == 0); console.assert(!(1 == 0)); 统计次数有时候我们需要统计一个函数或者被调用了几次，我们通常会增加一个变量count来记录，然后在控制台中查看。这样相当的麻烦，我们可以使用console.count函数来帮忙我们记录次数，并输出。 123456789101112function hi(name) &#123; console.count(name); return &quot;hi &quot; + name;&#125;for(var i = 0; i &lt; 10; i++) &#123; if(i &lt; 4) &#123; hi(&quot;person&quot;); &#125; else &#123; hi(&quot;god&quot;); &#125;&#125; 总结 console中有很多对我们调试代码有帮助的函数，我们可以在开发环境中配合console来调试代码，使得我们测试更加便利。 来自：https://segmentfault.com/a/1190000006721606]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex 布局]]></title>
    <url>%2F2016%2F09%2F12%2Fflex%2F</url>
    <content type="text"><![CDATA[网页布局（layout）是CSS的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex布局将成为未来布局的首选方案。本文介绍它的语法，下一篇文章给出常见布局的Flex写法。以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。一、Flex布局是什么？ Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。.box{ display: flex; o} 行内元素也可以使用Flex布局。.box{ display: inline-flex; } Webkit内核的浏览器，必须加上-webkit前缀。.box{ display: -webkit-flex; /* Safari */ display: flex; } 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。二、基本概念 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。三、容器的属性 以下6个属性设置在容器上。* flex-direction * flex-wrap * flex-flow * justify-content * align-items * align-content 3.1 flex-direction属性 flex-direction属性决定主轴的方向（即项目的排列方向）。.box { flex-direction: row | row-reverse | column | column-reverse; } 它可能有4个值。* row（默认值）：主轴为水平方向，起点在左端。 * row-reverse：主轴为水平方向，起点在右端。 * column：主轴为垂直方向，起点在上沿。 * column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } 它可能取三个值。（1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.3 flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。.box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } 3.4 justify-content属性 justify-content属性定义了项目在主轴上的对齐方式。.box { justify-content: flex-start | flex-end | center | space-between | space-around; } 3.5 align-items属性 align-items属性定义项目在交叉轴上如何对齐。.box { align-items: flex-start | flex-end | center | baseline | stretch; } 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。* flex-start：交叉轴的起点对齐。 * flex-end：交叉轴的终点对齐。 * center：交叉轴的中点对齐。 * baseline: 项目的第一行文字的基线对齐。 * stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 该属性可能取6个值。* flex-start：与交叉轴的起点对齐。 * flex-end：与交叉轴的终点对齐。 * center：与交叉轴的中点对齐。 * space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 * space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 * stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性 以下6个属性设置在项目上。* order * flex-grow * flex-shrink * flex-basis * flex * align-self 4.1 order属性 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。.item { order: &lt;integer&gt;; } 4.2 flex-grow属性 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。.item { flex-grow: &lt;number&gt;; /* default 0 */ } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。4.3 flex-shrink属性 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。.item { flex-shrink: &lt;number&gt;; /* default 1 */ } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。4.4 flex-basis属性 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。.item { flex-basis: &lt;length&gt; | auto; /* default auto */ } 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。4.5 flex属性 flex属性是flex-grow, flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。.item { flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ] } 该属性有两个快捷值：auto(1 1 auto)和none(0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。4.6 align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。.item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。作者：阮一峰来自：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3 text-shadow字体阴影]]></title>
    <url>%2F2016%2F09%2F11%2Fshadow%2F</url>
    <content type="text"><![CDATA[text-shadow:为字体添加阴影，可以通过对text-shadow属性设置相关的属性值，来实现现一些需要的字体阴影效果，减少了图片的使用。 基础说明：text-shadow: X轴 Y轴 Rpx color; 属性说明（顺序依次对应）：阴影的X轴(可以使用负值)、阴影的Y轴(可以使用负值)、阴影模糊值（大小）、阴影的颜色 注（PS）：此属性使用于文字阴影，而不是对盒模型进行操作，如果设置盒模型阴影请参考知识点:box-shadow（同理） IE下使用滤镜filter:shadow()和box-shadow一样都是css3新增的属性，为了兼容各主流浏览器并支持这些主浏览器的较低版本，基于主流浏览器上使用text-shadow属性时，我们需要将属性的名称前面加上前缀，谷歌和苹果浏览器-webkit-text-shadow的形式。 例如：-webkit-text-shadow:0 0 10px #c06; -moz-text-shadow:0 0 10px #C06; -o-text-shadow:0 0 10px #C06; text-shadow:0 0 10px #c06; 基础练习：(借鉴字体形式展示)一、常见形式：&lt;style type=&quot;text/css&quot;&gt; .pubdemo{ width: 320px; margin: 20px; padding:20px; font: bold 50px/100% &quot;微软雅黑&quot;; border:1px solid red} .demo1{ text-shadow: 0px 0 8px #F00} .demo2{ text-shadow: 5px 5px 8px #F00} .demo3{ text-shadow: -5px -5px 8px #F00} .demo4{ filter:shadow(Color=#f00000,Direction=45,Strength=8)} &lt;/style&gt; 1、没有给其X轴与Y轴设置值 所在会在本身发生作用 模糊半径范围，颜色&lt;p class=&quot;pubdemo demo1&quot;&gt;text-shadow&lt;/p&gt; 2、X轴与Y轴改变了正值（正值 向右 向下） 所以变成了这样&lt;p class=&quot;pubdemo demo2&quot;&gt;text-shadow2&lt;/p&gt; 3、X轴与Y轴改变成了负值（负值 向左 向上） 所以变成了这样&lt;p class=&quot;pubdemo demo3&quot;&gt;text-shadow3&lt;/p&gt; 4、 IE浏览器下&lt;p class=&quot;pubdemo demo4&quot;&gt;text-shadow3&lt;/p&gt; filter: Shadow(Color=’green’, Direction=’135’, Strength=’6’) Color设置阴影颜色 Direction阴影的方向 取值为0即零度（表示向上方向）、45为右上、90为右、135为右下、180为下方、225为左下方、270为左方、315为左上方 Strength就是范围，类似于text-shadow中的模糊半径值 filter: dropshadow(OffX=2, OffY=2, Color=’red’, Positive=’true’); 二、四个角（）阴影：&lt;style type=&quot;text/css&quot;&gt; *{ padding:0; margin:0} .pubjiao{ width: 350px; margin: 20px; font-size:20px; font- weight:bold; border:1px solid red } .pubjiao div{ float: left; width:140px; padding:10px; border:1px solid green} &lt;/style&gt; &lt;div class=&quot;pubjiao&quot;&gt; 左上角： text-shadow:-4px -4px 1px green; 左下角： text-shadow:-4px 4px 1px green; 右上角： text-shadow:4px -4px 1px green; 右下角： text-shadow:4px -4px 1px green; &lt;/div&gt; 三、多阴影—-加边例子（逗号隔开） 不明显：.kind1{ text-shadow: 0px 0px 2px green, 0px 0px 3px blue, 0px 0px 4px red; font-size:38px; color:yellow; } 四、自定义阴影-根据个人喜好所以制作1、类似于火焰&lt;style type=&quot;text/css&quot;&gt; .fire{ font-size:40px; font-weight:bold; background:#000; text-align:center; padding:24px; text-shadow:0 0 4px white, 0 -5px 4px #ff3, 3px -10px 6px #fd3, -3px -15px 11px #C90, 3px -25px 18px #f20; } &lt;/style&gt; &lt;p class=&quot;pubsty fire&quot;&gt;淡然&lt;/p&gt; 2、3D.threeD{ color:#fff; text-shadow: 0 0 1px #999, 1px 1px 2px #888, 2px 2px 2px #777, 3px 3px 2px #666, 4px 4px 2px #555, 5px 5px 2px #333; } &lt;p class=&quot;pubsty threeD&quot;&gt;淡然&lt;/p&gt; 3、等等多种（后期在新增）……百变不离其宗，练习就能熟悉，懂了就知道原理,随意改写，在配合css3的动画效果， 闪光层（字）都很简单实现。。希望对你有帮助。。 来自http://www.cnblogs.com/wuchuanlong/p/5985350.html]]></content>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可是姑娘，你为什么要编程呢？]]></title>
    <url>%2F2016%2F09%2F10%2FwhyProgramming%2F</url>
    <content type="text"><![CDATA[来自：http://kb.cnblogs.com/page/540529/作者: 于雪 发布时间: 2016-07-24 21:34 原文链接 本来你一个姑娘，可以去做一双贴满水晶的blingbling美甲更显十指纤纤，不用担心敲键盘不方便； 可以不时到健身房练练瑜珈来磨练心性，而不是通过看着满屏代码调bug； 可以洗完泡泡浴早早躺下睡个美容觉，而不是深夜赶紧贴上面膜，多少有些自欺欺人地告诉自己，刚才电脑的辐射才不会摧毁皮肤的水当当。 … … 可是突然有一天，你开始发现代码这个东西的魔力： 在安安静静码代码，认认真真调代码之后，运行结果展示那一瞬间…功能实现了，那是能上天的一种感受。于是，你开始了从“网络失足女青年”到“勤奋刻苦程序媛”的跨越。刻苦程序媛”的跨越。 我几乎确定，你想象中程序媛的日常： 是家人视你为改变世界的Suprewoman，从此“别人家的孩子”是路人； 是集领导、同事万千宠爱于一身的“代码小公举”，特别是在大姨妈到访时谁见都怜； 是程序猿们待你如坠落屌丝界的天使，左拥右围，众猩捧月。 然而现实却是家人听闻你的职业后，满脸大写的： “好好一个姑娘，长得也挺漂亮，做什么程序员？！” 工作时完全没有优待，该写代码写代码，该调bug调bug，该撕逼撕逼；每天混迹在众多男程序员当中，确实还有那么一点儿优越感，但前提是你司并没有多余的钱花在传说中的鼓励师身上。 作为程序媛的你，经常感受着他们不明来历的恶意。 代码写的没他们好，他们说：“到底还是妹子！”，代码写的比他们好，他们说：“到底还是不是妹子？！”； 细致、踏实、有责任心的你们，往往在各种复杂的大项目中发挥重要优势。特别是那双挑bug的明亮美眸，怒甩他们几十条街，然而得到的评价是“找茬是女人的天性”； 终于熬到了调查研究的结论验明正身： “女程序员的代码往往写得比男性更好” 正准备好姿势开始扬眉吐气时看到了后半句话，“但是，得到这种认可有个前提，就是她们必须保密自己的性别…女性程序员的代码接受率可以达到78.6%，比男性程序员的74.6%要高。然而，若女程序员对外公开自己的性别，其代码接受率便出现了大幅下降，只剩下62.5%。” ……忍了。毕竟还是比他们高。 然而又有好事者发出声音： “为什么女程序员普遍代码写得比较好？因为每一个成功的程序媛背后，都有一个用心帮她们改代码的程序员。” 是可忍，孰不可忍〜叔可忍，婶儿也忍不了了！快快前来跪见你们的祖师奶！！ 阿达·洛芙莱斯世界上第一位计算机程序员 其实别人的质疑并不可怕，可怕的是你自己对是否继续前行没了底气。 程序媛好找工作吗？我该不该放弃？ 程序媛好找对象吗？我该不该放弃？ 程序媛职业发展会受到限制吗？我该不该放弃？ …… 那么姑娘，你是后悔了？可是又有哪种职业不会让女性放下对结婚生子的顾虑呢？而且如果不当程序媛，我们还是嫁不出去，这个锅又该谁背呢？ 还记不记得你当初为什么选择编程？ 那时的你，并没有把写代码看成是只为谋生的机械行为，而是看作如绘画或雕刻一样的艺术。你如弹奏钢琴一般敲击键盘，每行代码都是最美的乐章。当串联起来的激情在运行那一瞬间得到释放时，那感觉……比吃辣条还叫人销魂！ 再说，程序员的工作职责又不包括搬砖和扛大包，有什么拼不过老爷们儿的呢？决定你适不适合这项工作的不是性别，而是兴趣；决定你能不能做好的也不是性别，而是够不够努力。 所以，姑娘，为了做一枚花见花开的程序媛，你也许应该: 警惕女程序员的陷阱。女程序员工作认真踏实，细致负责，这是女性与生俱来的优势，在配置管理、运维监控这些工作中，女程序员通常完成的非常出色。 而且在做了职场妈妈后，女性更加追求安稳，不愿意再跳槽折腾。公司领导喜欢这样的员工。 但如果你因为这些就沾沾自喜，并且乐于工作轻松，那么你就可能掉进了女程序员的陷阱。长期从事这些复杂度低、重复性高的工作中，很容易将自己原来的技术荒废掉，并且也不会再想学习新的技术。 长久以来，可能在一个岗位中呆了十几年，在技术上完全没有竞争力。 女程序员更容易被边缘化，因此在职业规划上一定要更加精心。无论性别，想要做好程序员，只是埋头干好自己分内的工作是远远不够的。 试试尝试新的技术，或在空闲时间会一些小工具帮大家提高效率。赠人玫瑰，手有余香。 不要放弃学习，多看一些书。技术对谁都是公平的，它日新月异的发展，不学习就别想跟上它的脚步。将视野放的广一些，去了解和学习更多你现在的工作中可能用不到的技术。比如你可能懂得只是数据挖掘之类技术的皮毛，但同事们已经觉得你碉堡了。 当然，书并不是只有《算法与编程》这种。看更多的书，阅读不仅能帮你拓展思路，改变思维习惯，还会丰富与别人的谈资。 享受与人沟通。可能是由于职业的原因，整天对着电脑，程序员们往往会觉得人际关系太复杂了，不如电脑，输入和输出都是事实。也容易给人留下不善沟通、枯燥刻板的印象。 但女性在性格上天生更加细腻、温和，也更能站在对方的角度考虑问题，这也可能使程序媛在了解需求时表现得更容易。 在IT公司，大家大部分时间都在和机器打交道，如果你还恰好自备卖萌、自黑、抖机灵，并知道怎么恰当的调戏身边木讷的程序员哥哥，你还发愁在这帮秃小子之中当不上女神吗？ 另外，在遇到问题时不要太追求独力解决，多和项目组的高手讨论，哪怕只是抛出一些比较有深度的问题，你就能了解别人遇到这样的问题是如何实现的，加以总结变成自己的经验，或许你还能想到更好的办法，这个过程，你会获得比答案更多的知识。 化一点淡妆，如果你愿意。其实，设计也只是一份职业而已，和编辑、销售、文职一样。程序媛一样可以画个美美的淡妆，每天精心搭配衣服，靓靓地去上班。 当然，如果你觉得这样不自在，那就不必。我们做的这些，只是为了让自己更加舒服和自信。 另外，由于程序媛每天工作时间很长，坐的太久不仅让身材走样，还会引起身体不适。尝试着在休息时间多走出家门，登登山，跑跑步，用新鲜的果汁代替咖啡来提神，也许你会感受到由心到身的轻松和舒畅。 所以，你看，姑娘，女程序员没什么特别的。就像男程序员爱看篮球打LOL，我们当然也可以追韩剧逛淘宝。更妙的是，在满足过硬的技术功底条件下，你的性别本身就是一种优势。 “像汉子一样工作，像妹子一样生活。选择编程只是为了有一种选择让你离想要的幸福更近。” 最后，祝每位程序媛女王节快乐。]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七种CSS方式让一个容器水平垂直居中]]></title>
    <url>%2F2016%2F09%2F10%2Fcenter%2F</url>
    <content type="text"><![CDATA[目录方法一： position+margin方法二： position+transform方法三： display:table-cell方法四： display:flex;align-items:center;justify-content:center;方法五： display:flex;margin:auto方法六： 纯position方法七： 兼容低版本浏览器，不固定宽高总结这种css布局平时用的比较多，也是面试题常出的一个题，网上一搜一大丢，不过还是想自己总结一下。 这种方法比较多，本文只总结其中的几种，以便加深印象。 方法一： position+margin&lt;!-- html --&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;/div&gt; /* css */ .wrap { width: 200px; height: 200px; background: yellow; position: relative; } .wrap .center { width: 100px; height: 100px; background: green; margin: auto; position: absolute; left: 0; right: 0; top: 0; bottom: 0; } 兼容性：主流浏览器均支持，IE6不支持 方法二： position+transform&lt;!-- html --&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;/div&gt; /* css */ .wrap{ width: 200px; height: 200px; background: yellow; display: table-cell; vertical-align: middle; text-align: center; } .center{ display: inline-block; vertical-align: middle; width: 100px; height: 100px; background: green; } 兼容性：由于display:table-cell的原因，IE6\7不兼容 方法三： display:table-cell&lt;!-- html --&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;/div&gt; /* css */ .wrap{ width: 200px; height: 200px; background: yellow; display: table-cell; vertical-align: middle; text-align: center; } .center{ display: inline-block; vertical-align: middle; width: 100px; height: 100px; background: green; } 兼容性：由于display:table-cell的原因，IE6\7不兼容 方法四： flex;align-items: center;justify-content: center;&lt;!-- html --&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;/div&gt; /* css */ .wrap { background: yellow; width: 200px; height: 200px; display: flex; align-items: center; justify-content: center; } .center { background: green; width: 100px; height: 100px; } 移动端首选 方法五： display:flex;margin:auto&lt;!-- html --&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;/div&gt; /* css */ .wrap { background: yellow; width: 200px; height: 200px; display: flex; } .center { background: green; width: 100px; height: 100px; margin: auto; } 移动端首选 方法六： 纯position&lt;!-- html --&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;/div&gt; /* css */ .wrap { background: yellow; width: 200px; height: 200px; position: relative; } /* 方法一 */ .center { background: green; position: absolute; width: 100px; height: 100px; left: 50px; top: 50px; } /* 方法二 */ .center { background: green; position: absolute; width: 100px; height: 100px; left: 50%; top: 50%; margin-left:-50px; margin-top:-50px; } 兼容性：适用于所有浏览器 方法六中的方法一计算公式如下： 子元素（conter）的left值计算公式：left=(父元素的宽 - 子元素的宽 ) / 2=(200-100) / 2=50px; 子元素（conter）的top值计算公式：top=(父元素的高 - 子元素的高 ) / 2=(200-100) / 2=50px; 方法二计算公式：left值固定为50%; 子元素的margin-left= -（子元素的宽/2）=-100/2= -50px; top值也一样，固定为50% 子元素的margin-top= -（子元素的高/2）=-100/2= -50px; 方法七： 兼容低版本浏览器，不固定宽高&lt;!-- html --&gt; &lt;div class=&quot;table&quot;&gt; &lt;div class=&quot;tableCell&quot;&gt; &lt;div class=&quot;content&quot;&gt;不固定宽高，自适应&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; /* css */ .table { height: 200px;/*高度值不能少*/ width: 200px;/*宽度值不能少*/ display: table; position: relative; float:left; background: yellow; } .tableCell { display: table-cell; vertical-align: middle; text-align: center; *position: absolute; padding: 10px; *top: 50%; *left: 50%; } .content { *position:relative; *top: -50%; *left: -50%; background: green; } 暂时总结上面的七种，这种方法太多，其实只要习惯了其中的一两种也就够用了。 这种css元素垂直的如果真的要总结起来，应该有十几二十几种。不过也没必要全部掌握吧，只要大概了解一些，用起来没有副作用就行。 有误之处，欢迎指出 转自：http://www.cnblogs.com/xianyulaodi/p/5863305.html]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2016%2F09%2F05%2FblogBuliding%2F</url>
    <content type="text"><![CDATA[hexo是一款基于Node.js的静态博客框架 在安装前我们需要github账号一个，具体流程不进行说明。 现在开始搭建属于自己的博客安装node.jsnode.js官网 https://nodejs.org/en/ 测试是否安装node.js node.js -v 开始安装hexonpm install hexo -g 首先先创建一个文件夹 然后用终端进入该文件夹后输入 hexo int 到这里hexo博客算是初步搭建好了，然后在刚刚建的文件夹里找到_config.yml打开找到deploy字段 type: git repo: github的域名仓库的https地址 接下来我们就可以发布我们的博客npm install hexo-deploy-git --save hexo g 生成静态页面 hexo d 部署，发布到github上 到这里我们的博客算是真正的搭建好了还有一些其他指令hexo server(或hexo s) 本地测试 hexo new 文件名 创建文件 hexo h 查看帮助 hexo v 查看Hexo的版本 转载标明出处或联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mou的语法编写]]></title>
    <url>%2F2016%2F09%2F05%2Fmou%2F</url>
    <content type="text"><![CDATA[Mou语法对照打开方式菜单栏中Help --&gt; Mou Help 效果如下 转载标明出处或联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F09%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 转载标明出处或联系：1328271467 &amp; zjfbaby@icloud.com &amp; 1328271467@qq.com]]></content>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
</search>
